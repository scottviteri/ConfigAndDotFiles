/- Quantifiers and Equality
 Add universal and existential quantification, and the equality relation to the the mix of propositional connectives
-/

namespace univ_quant_1
  -- Universal Quantifier
  variables (α : Type) (p q : α → Prop)
  example : (∀ x : α, p x ∧ q x) → ∀ y : α, p y :=
    assume (hpq : ∀ x : α, p x ∧ q x),
    assume (y : α),
    show p y, from (hpq y).left

  example : (forall x : α, p x ∧ q x) → ∀ x : α, p x :=
    assume (hpq : ∀ x : α, p x ∧ q x),
    assume (x : α),
    show p x, from (hpq x).left

  variable r : α → α → Prop -- form of a binary relation
  variable trans_r : ∀ x y z, r x y → r y z → r x z
  variables a b c : α
  variables (hab : r a b) (hbc : r b c)

  #check trans_r
  #check trans_r a b c
  #check trans_r a b c hab hbc


end univ_quant_1

namespace univ_quant_2

  variable (α : Type)
  variable (r : α → α → Prop)
  variables (a b c d : α)

  variable refl_r : ∀x, r x x
  variable symm_r : ∀ {x y} , r x y → r y x
  variable trans_r : ∀ {x y z}, r x y → r y z → r x z
  -- trans_r already specified

  variables (hab : r a b) (hbc : r b c)
  #check trans_r hab hbc
  #check symm_r hab

  example (a b c d : α) (hab : r a b) (hcb : r c b) (hcd : r c d) : r a d :=
    have hbc : r b c, from symm_r hcb,
    trans_r (trans_r hab hbc) hcd

  #check eq.refl
  #check eq.symm
  #check eq.trans

  universe u
  #check @eq.refl.{u}
  #check @eq.symm.{u}
  #check @eq.trans.{u} -- ∀ (α : Sort u) (a b c : α), a = b → b = c → a = c

end univ_quant_2

namespace univ_quant_3

  universe u
  variables (α : Sort u) (a b c d : α) (hab : a = b) (hcb : c = b) (hcd : c = d)

  example : a = d :=
    have hbc : b = c, from eq.symm hcb,
    show a = d, from eq.trans hab (eq.trans hbc hcd)

  #check hab.trans hcb.symm
  example : a = d := (hab.trans (hcb.symm.trans hcd))

end univ_quant_3

namespace univ_quant_4

  universe u

  variables (α β : Type u)
  #print eq.refl
  #check eq.refl α

  example (f : α → β) (a : α) : (λ x, f x) a = f a := eq.refl (f a)
  example (f : α → β) (a : α) : (λ x, f x) a = f a := eq.refl _
  example (a b : α) : (a, b).1 = a := eq.refl a
  example (a b : α) : (a, b).1 = a := eq.refl _

  example : 2 + 3 = 5 := eq.refl _
  example : 2 + 3 = 5 := rfl

  /-
  eq has another property besides that it is an equivalence relation.
  Substition of an equal value does not change the truth value of an expression.
  h1 : a = b and h2 : p a  → eq.subst h1 h2 : p b
  -/

  example (α : Type u) (a b : α) (p : α → Prop) (h1 : a = b) (h2 : p a) : p b :=
    eq.subst h1 h2

  example (α : Type u) (a b : α) (p : α → Prop) (h1 : a = b) (h2 : p a) : p b :=
    h1 ▸ h2

end univ_quant_4

namespace univ_quant_5
  variables (α : Type) (a b : α) (f g : α → ℕ) (h1 : a = b) (h2 : f = g)
  #check congr_arg
  #check congr_fun
  #check congr

  example : f a = f b := congr_arg f h1
  example : f a = g a := congr_fun h2 a
  example : f a = g b := congr h2 h1

end univ_quant_5

namespace univ_quant_6
  variables a b c d : ℤ
  #print add_zero
  #print mul_one
  #print add_assoc

  example : a + 0 = a := add_zero a
  example : 0 + a = a := zero_add a
  example : a * 1 = a := mul_one a
  example : 1 * a = a := one_mul a
  example : -a + a = 0 := neg_add_self a
  example : a + -a = 0 := add_neg_self a
  example : a + b = b + a := add_comm a b
  example : a + b + c = a + (b + c) := add_assoc a b c
  example : a * b = b * a := mul_comm a b
  example : a * b * c = a * (b * c) := mul_assoc a b c
  example : a * (b + c) = a * b + a * c := mul_add a b c
  example : a * (b + c) = a * b + a * c := left_distrib a b c
  example : (a + b) * c = a * c + b * c := add_mul a b c
  example : (a + b) * c = a * c + b * c := right_distrib a b c
  example : a * (b - c) = a * b - a * c := mul_sub a b c
  example : (a - b) * c = a * c - b * c := sub_mul a b c

  variables x y z : ℤ
  example (x y z : ℕ) : x * (y + z) = x * y + x * z := mul_add x y z
  example (x y z : ℕ) : (x + y) * z = x * z + y * z := add_mul x y z
  example (x y z : ℕ) : x + y + z = x + (y + z) := add_assoc x y z

  #check (mul_add (x + y) x y)
  example (x y : ℕ) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
    have h1 : (x + y) * (x + y) = (x + y) * x + (x + y) * y, from mul_add (x + y) x y,
    have xy_times_x : (x + y) * x = x * x + y * x, from add_mul x y x,
    have xy_times_y : (x + y) * y = x * y + y * y, from add_mul x y y,

    have h2 : (x + y) * (x + y) = x * x + y * x + (x * y + y * y),
      from xy_times_x ▸ (xy_times_y ▸ h1),
    h2.trans (add_assoc (x * x + y * x) (x * y) (y * y)).symm

end univ_quant_6

namespace calc_pfs
  variables (a b c d e : ℕ)
  variables (h1 : a = b) (h2 : b = c + 1) (h3 : c = d) (h4 : e = 1 + d)

  #check add_comm 1 d
  theorem T : a = e :=
  calc
    a   = b : h1
    ... = c + 1 : h2
    ... = d + 1 : congr_arg _ h3
    ... = 1 + d : add_comm d (1:ℕ)
    ... = e : h4.symm

  include h1 h2 h3 h4
  theorem T' : a = e :=
  calc
    a   = b : by rw h1
    ... = c + 1 : by rw h2
    ... = d + 1 : by rw h3
    ... = 1 + d : by rw add_comm
    ... = e : by rw h4

  theorem T'' : a = e :=
  calc
    a   = d + 1 : by rw [h1, h2, h3]
    ... = 1 + d : by rw add_comm
    ... = e : by rw h4

  theorem T''' : a = e := by rw [h1, h2, h3, add_comm, h4]

  theorem T'''' : a = e :=
    by simp [h1, h2, h3, h4]



end calc_pfs

namespace calc_pfs_2
  -- calc can be used with any relation that supports transitivity

  #check gt
  #check has_lt.lt

  theorem T2 (a b c d : ℕ) (h1 : a = b) (h2 : b ≤ c) (h3 : c + 1 < d) : a < d :=
    calc
      a   = b : h1
      ... < b + 1 : nat.lt_succ_self b
      ... ≤ c + 1 : nat.succ_le_succ h2
      ... < d : h3

  theorem T (x y : ℕ) : (x + y) * (x + y) = x * x + y * x + x * y + y *y :=
    calc
      (x + y) * (x + y) = (x + y) * x + (x + y) * y : by rw mul_add
                    ... = x * x + y * x + (x + y) * y : by rw add_mul
                    ... = x * x + y * x + (x * y + y * y) : by rw add_mul
                    ... = x * x + y * x + x * y + y * y : by rw ←add_assoc

  theorem T' (x y : ℕ) : (x + y) * (x + y) = x * x + y * x + x * y + y *y :=
    by rw [mul_add, add_mul, add_mul, ←add_assoc]

  theorem T'' (x y : ℕ) : (x + y) * (x + y) = x * x + y * x + x * y + y *y :=
    by simp [mul_add, add_mul]


end calc_pfs_2

namespace exist_quant

  #print nat
  /-
    Has both intro and elimination rules
    (exists x : α, p x) and (∃ x : α, p x)
     shorthand for Exists (λ x : α, p x)
  -/

  -- how to prove a < b from b > a ??
  /-
    need some kind of eliminator for has_lt.lt
    examples of eliminator:
      bool -> if bool then a else b
      and -> and.elim : (a ∧ b) → (a → b → c) → c
             and.elim_left : (a ∧ b) → a
             and.elim_right : (a ∧ b) → b
      or -> or.elim : (a ∨ b) → (a → c) → (b → c) → c
      iff -> iff.elim : ((a → b) → (b → a) → c) → a ↔ b → c
             iff.elim_left : (a ↔ b) → a → b
             iff.elim_right : (a ↔ b) → b → a
      true -> (no elim rule)
      false -> false.elim : false → a

    Syntax:
      and, iff -- structures
      or, bool, true, false -- inductive
      implies -- def

      def and.elim_left
      def and.elim_right
      def false.elim

      lemma iff.elim
      lemma iff.elim_left
      lemma iff.elim_right
      lemma or.elim
      lemma and.elim

  Search through inductive defs in core.lean
    punit, true, sum, psum, or, option, list, nat, bin_tree

  (Note to self --
    difficult to search for things without helm
    many different versions of syntax
    eg namespace or, lemma elim
  )

  so eliminators defined like anything else
    but maybe only for prop
    because didn't find anything like nat.elim or bool.elim
  but I do not that if acts like an eliminator on bool
    but can't find definition of if anywhere

  -/

  #print Exists
  #check exists.intro (1:ℕ)
  #check nat.lt_succ_self (0:ℕ)
  #check has_lt.lt
  #check false.elim

  /-
    gt is defined as def
    but lt is a constructor of a typeclass has_lt

  variables (a b : ℕ) (hab : has_lt.lt a b)
  #check gt b a

  theorem flipp : gt a b :=
    (λ x, λ y, hab)
  turns out it is done implicitly lol ...
  -/

  #check exists.intro
  example : ∃ x : ℕ, x > 0 :=
    have h : 1 > 0, from nat.zero_lt_succ 0,
    exists.intro 1 h

  example (x : ℕ) (h : x > 0) : ∃ y, y < x :=
    exists.intro 0 h

  example : ∃ x : ℕ, x > 0 :=
    have h : 0 < 1, from nat.lt_succ_self 0,
    exists.intro 1 h

  #check nat.succ 0
  #check and.intro

  example (x y z : ℕ) (hxy : x < y) (hyz : y < z) : ∃ w, x < w ∧ w < z :=
    exists.intro y (and.intro hxy hyz)

  #check exists.intro
  #check @exists.intro

  example : ∃ x : ℕ, x > 0 :=
    ⟨1, nat.lt_succ_self 0⟩

  example (x : ℕ) (h : x > 0) : ∃ y, y < x :=
    ⟨0, h⟩

  example (x y z : ℕ) (hxy : x < y) (hyz : y < z) : ∃ w, x < w ∧ w < z :=
    ⟨y, and.intro hxy hyz⟩
  example (x y z : ℕ) (hxy : x < y) (hyz : y < z) : ∃ w, x < w ∧ w < z :=
    ⟨y, hxy, hyz⟩


  variable g : ℕ → ℕ → ℕ
  variable hg : g 0 0 = 0

  theorem gex1 : ∃ x, g x x = x := ⟨0, hg⟩
  theorem gex2 : ∃ x, g x 0 = x := ⟨0, hg⟩
  theorem gex3 : ∃ x, g 0 x = x := ⟨0, hg⟩
  theorem gex4 : ∃ x, g x x = 0 := ⟨0, hg⟩

  set_option pp.implicit true -- display implicit arguments
  #print gex1
  #check @Exists
  #print gex2

  -- exists.intro is essentially an information-hiding operation
  --   it hides the body of the assertion
  -- exists.elim requires showing that q follows from p w for an arbitrary w

  variables (α : Type) (p q : α → Prop)

  #check exists.elim
  example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
    exists.elim h
      (show Π (x : α), p x ∧ q x → (∃ x, q x ∧ p x),
       from (assume (w : α) (hpq : p w ∧ q w), exists.intro w hpq.symm))

  -- more convenient to eliminate existential with match statement

  example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
    match h with ⟨w, hw⟩ :=
      ⟨w, ⟨hw.right, hw.left⟩⟩
    end

  -- match comes from Lean's fxn definition fxnality
  --  can co-opt for use here

  example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
    match h with ⟨(w : α), (hw : p w ∧ q w)⟩ :=
      ⟨w, hw.right, hw.left⟩
    end

  example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
    match h with ⟨w, hpw, hqw⟩ :=
      ⟨w, hqw, hpw⟩
    end

  example (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
    let ⟨w, hpw, hqw⟩ := h in ⟨w, hqw, hpw⟩

  example : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x :=
    assume ⟨w, hpw, hqw⟩, ⟨w, hqw, hpw⟩

  def is_even (a : ℕ) := ∃ b, a = 2 * b

  theorem even_plus_even {a b : ℕ} (ha : is_even a) (hb : is_even b) : is_even (a+b) :=
    exists.elim ha (assume wa, assume hwa : a = 2 * wa,
      exists.elim hb (assume wb, assume hwb : b = 2 * wb,
        exists.intro (wa + wb)
          (calc
            a + b = 2 * wa + 2 * wb : by rw [hwa, hwb]
            ...   = 2 * (wa + wb)   : by rw mul_add)))

  theorem even_plus_even' {a b : nat} (ha : is_even a) (hb : is_even b) : is_even (a + b) :=
    match ha, hb with ⟨wa, hwa⟩, ⟨wb, hwb⟩ :=
      ⟨wa + wb, by rw [hwa, hwb, mul_add]⟩
    end

  -- the classical version of exists does not need a particular example
  open classical
  variables (α : Type) (p : α → Prop)

  #check by_contradiction
  #check Γ ⊢ M : A Γ ⊢ M = N : A

  example (h : ¬ ∀ x, ¬ p x) : ∃ x, p x :=
    -- I have a proposition that not every x satisfies (¬ p x)
    by_contradiction








end exist_quant
