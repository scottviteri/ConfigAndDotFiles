#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

** Tree reading / manipulation utilities
*** Top level imports

#+BEGIN_SRC python :session :results output silent

import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json
import functools
import pdb
import cProfile
import subprocess
import networkx as nx
import os
import random
import community

#+END_SRC

#+RESULTS:

*** Read tree files into nested lists

First, grab some sample proof trees.

#+BEGIN_SRC python :session :results output silent
ev_4_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2))'
ev_8_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2)) (Definition Top.ev_8 (App ev_SS (App S (App S (App S (App S (App S (App S O)))))) (App ev_SS (App S (App S (App S (App S O)))) Top.ev_4)))'
#+END_SRC

#+RESULTS:

We will need to parse these into a form that python can more directly read.

I am using a list of lists, where [A,B,[C,D]] represents
 A
 |\
 B C
   |
   D

**** Trees to nested lists, without natural number substitution

#+BEGIN_SRC python :session :results output silent

def focusToNewLetters(focus_string):
    if focus_string[1] == '(': return '['
    elif focus_string[1] == ')': return ']'
    elif focus_string[1] == ' ': return ','
    if focus_string[1].isalnum() \
        and (focus_string[0] == '(' or focus_string[0] == ' ') \
        and (focus_string[2] == ')' or focus_string[2] == ' '):
        return '\"'+focus_string[1]+'\"'
    if focus_string[1] not in '( )' and (focus_string[0] == '(' or focus_string[0] == ' '):
        # (a -> ("a or ' a' -> ' "a'
        return '\"'+focus_string[1]
    if focus_string[1] not in '( )' and (focus_string[2] == ')' or focus_string[2] == ' '):
        # b) -> b") or 'b ' -> 'b" '
        return focus_string[1]+'\"'
    return focus_string[1]

#+END_SRC

**** Tree printing utilities

#+BEGIN_SRC python :session :results output silent

def isFlat(l):
    return not any(filter(lambda x: isinstance(x,list), l))

def concat(lst_of_lsts):
    return functools.reduce(lambda x,y:x+y, lst_of_lsts, [])

def printTreeHelper(tree):
    """ Prints tree by prepending '+---' to each layer
    Example: printTreeHelper(['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']])
    # base: ['App', 'ev_SS', 'O', 'ev_0'] -> ['App', '+---ev_SS', '+---O', '+---ev_0']
    # ind_step: ['Definition', 'Top.ev_2', ['App', '+---ev_SS', '+---O', '+---ev_0']]
    #  -> ['Definition', '+---Top.ev_2', '+---App', '+---+---ev_SS', '+---+---O', '+---+---ev_0']]
    """
    h,t = tree[0], tree[1:]
    if not isinstance(tree, list):
        assert(isinstance(tree, str))
        return [tree]
    if isFlat(tree):
        return [h] + list(map(lambda x: "+---"+x, t))
    return [h] + concat([list(map(lambda x: "+---"+x, printTreeHelper(x))) for x in t])

def printTree(tree, max_depth=None):
    for x in printTreeHelper(tree):
        if max_depth is not None:
            if "+---"*max_depth not in x:
                print(x)
        else:
            print(x)


#+END_SRC

**** Substitute nat notation of App S chains

#+BEGIN_SRC python :session :results output silent

# let search_val be a flat list
def replaceFlatList(lst_of_lsts, search_val, replace_val):
    l = []
    for x in lst_of_lsts:
        if search_val == x:
            l.append(replace_val)
        else:
            if isinstance(x,list):
                if isFlat(x):
                    l.append(x)
                else:
                    l.append(replaceFlatList(x, search_val, replace_val))
            else:
                l.append(x)
    return l

def subNats(lst_of_lsts):
    l = replaceFlatList(lst_of_lsts, ['App','S','O'], '1')
    last_l = None
    n = 1
    while last_l != l:
       last_l = l
       l = replaceFlatList(l, ['App','S',str(n)], str(n+1))
       n += 1
    return l

def parenStringToLists(paren_string, debug=False):
    accum = ''
    paren_string = paren_string.strip()
    #print(paren_string.count('('), paren_string.count(')'))
    assert(paren_string.count('(') == paren_string.count(')'))
    focus = "  " + paren_string[0]
    for char in paren_string[1:]:
        focus = focus[1:] + str(char)
        accum += focusToNewLetters(focus)
        #print(focus[1], focusToNewLetters(focus))
    accum += ']'
    if debug:
    	with open('paren_lists_debug.txt','w') as f:
            f.write(accum)
    theorem_rev = subNats(json.loads(accum))
    return [theorem_rev[0]] + theorem_rev[1:][::-1]

def theoremNameToLists(theorem_name, depth=2, debug=False):
    theorem_folder = './ProofTrees/Individual/'+theorem_name
    if not os.path.exists(theorem_folder):
        subprocess.call(["./coq_proof_to_trees.sh", theorem_name])
    with open(theorem_folder + '/d'+str(depth)+'.txt', 'r') as f:
        paren_string = f.read()
    assert(paren_string != '')
    return parenStringToLists('(Top ' + paren_string.strip() + ')', debug=debug)

#assert(parenStringToLists('(a b (c d e))') == ['a','b',['c','d','e']])

ev_4_tree = theoremNameToLists('ev_4')
ev_4_alt_tree = theoremNameToLists('ev_4_alt')
ev_8_tree = theoremNameToLists('ev_8')
ev_8_alt_tree = theoremNameToLists('ev_8_alt')
sqrt2_tree = theoremNameToLists('sqrt2_not_rational')

printTree(ev_8_alt_tree,4)
printTree(sqrt2_tree, 3) #notice -- all props

#+END_SRC

#+RESULTS:

*** Substitute definitions back into the original tree branch -- tree modulo theorems

#+BEGIN_SRC python :session :results output silent

def replaceVal(lst_of_lsts, search_val, replace_val):
    """ similar to subRec, but search target is a single value """
    lst = []
    for elem in lst_of_lsts:
        if search_val == elem:
            lst.append(replace_val)
        else:
            if isinstance(elem,list):
                lst.append(replaceVal(elem, search_val, replace_val))
            else:
                lst.append(elem)
    return lst

def replaceVals(lst_of_lsts, search_replace_dict):
    """ similar to replaceVal, but multiple search targets with different replace_vals """
    l = []
    for x in lst_of_lsts:
        if isinstance(x,list):
            l.append(replaceVals(x, search_replace_dict))
        else:
            if x in search_replace_dict:
                l.append(search_replace_dict[x])
            else:
                l.append(x)
    return l

def replaceValsEffect(lst_of_lsts, search_replace_dict):
    for i in range(len(lst_of_lsts)):
        x = lst_of_lsts[i]
        if isinstance(x,list):
            replaceValsEffect(x, search_replace_dict)
        else:
            if x in search_replace_dict:
                lst_of_lsts[i] = search_replace_dict[x]


def accumMatches(lst_of_lsts, test):
    l = []
    for x in lst_of_lsts:
        if isinstance(x, list):
            l.extend(accumMatches(x, test))
        else:
            if test(x):
                l.append(x)
    return l

def inNestedList(elem, lst_of_lsts):
    for x in lst_of_lsts:
        if isinstance(x,list):
            if inNestedList(elem, x):
                return True
        else:
            if elem == x:
                return True
    return False

#def inNestedList2(elem, lst_of_lsts):
#    frontier = [lst_of_lsts]
#    while 1:
#        current_elem = frontier.pop(0)

def allAtLeaves(elems, tree):
    l = []
    if isinstance(tree, list):
        for x in tree[1:]:
            l.extend(allAtLeaves(elems, x))
    else:
        if tree in elems:
            l.append(tree)
    return l

assert(allAtLeaves(['a','b','c'], ['a',['b','c']]) == ['c'])

def replaceDefinitions(lst_of_lsts, max_depth=math.inf, debug=False):
    """ Substitute unrolled definitions back into main top level definition """
    orig_tree, dep_trees = lst_of_lsts[1], lst_of_lsts[2:]
    replace_string_candidates = list(map(lambda x:x[1], dep_trees))
    def_to_subtree = {x[1]:x[2] for x in lst_of_lsts}
    dep_dict = {x[1]: set(allAtLeaves(replace_string_candidates, x[2])) for x in lst_of_lsts}
    replace_strings = dep_dict[orig_tree[1]]
    depth = 0
    search_replace_dict = {}
    while replace_strings and depth < max_depth:
        search_replace_dict = {k:def_to_subtree[k] for k in replace_strings}
        orig_tree = replaceVals(orig_tree, search_replace_dict)
        depth += 1
        replace_strings = set().union(*[dep_dict[x] for x in replace_strings])
    search_replace_dict = {k:def_to_subtree[k] for k in replace_strings}
    orig_tree = replaceVals(orig_tree, search_replace_dict)
    if debug:
        with open('replace_def_debug.txt','w') as f:
            f.write(str(orig_tree))
    return orig_tree

#def replaceDefinitions(defs, max_depth=math.inf, debug=False):
#    """ Substitute unrolled definitions back into main top level definition """
#    lst_of_lsts = copy.deepcopy(defs)
#    orig_tree, dep_trees = lst_of_lsts[1], lst_of_lsts[2:]
#    replace_string_candidates = list(map(lambda x:x[1], dep_trees))
#    def_to_subtree = {x[1]:x[2] for x in lst_of_lsts}
#    dep_dict = {x[1]: set(allAtLeaves(replace_string_candidates, x[2])) for x in lst_of_lsts}
#    replace_strings = dep_dict[orig_tree[1]]
#    depth = 0
#    search_replace_dict = {}
#    while replace_strings and depth < max_depth:
#        search_replace_dict = {k:def_to_subtree[k] for k in replace_strings}
#        replaceValsEffect(orig_tree, search_replace_dict)
#        depth += 1
#        replace_strings = set().union(*[dep_dict[x] for x in replace_strings])
#    search_replace_dict = {k:def_to_subtree[k] for k in replace_strings}
#    replaceValsEffect(orig_tree, search_replace_dict)
#    if debug:
#        with open('replace_def_debug.txt','w') as f:
#            f.write(str(orig_tree))
#    return orig_tree


#printTree(ev_4_tree)
#printTree(replaceDefinitions(ev_4_tree))

printTree(ev_8_alt_tree,4)
print()
print()
printTree(replaceDefinitions(ev_8_alt_tree),4)

#+END_SRC

#+RESULTS:

** Analyze features of proof trees
*** Proof tree plotting utilities

#+BEGIN_SRC python :session :results output silent

def sumLsts(lsts):
    max_len = max(map(len, lsts))
    def zeroFill(lst): return lst + [0]*(max_len - len(lst))
    return list(map(sum, zip(*map(zeroFill,lsts))))

def countNodesAtDepths(tree):
    """ Counts num nodes at each depth
    Example: countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']])
    # base: ['c','d','e'] -> [1,2], 'b' -> [1]
    # ind_step: ['a', [1], [1,2], [1,2]] -> [1,3,4]
    """
    if not isinstance(tree, list): return [1]
    h,t = tree[0], tree[1:]
    if isFlat(tree): return [1,len(t)]
    return [1] + sumLsts(list(map(countNodesAtDepths, t)))

def countNodes(tree):
    if not isinstance(tree, list): return 1
    return 1 + sum([countNodes(branch) for branch in tree[1:]])

def findAdd(tree):
    if not isinstance(tree, list):
        return False
    else:
        if tree[0] == 'add':
            print(tree)
            return True
        return any([findAdd(t) for t in tree[1:]])

def strip(s):
    return s.split('/')[-1]

def modStrip(s):
    l = s.split('/')
    return l[-2] + '_' + l[-1]

assert(countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']]) == [1,3,4])

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output silent

def plotNodesVTreeDepth(theorem_name, max_depth, debug=False):
  f = 'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
  if not os.path.isfile(f):
      fig, ax = plt.subplots(figsize=(6,6))
      for d in range(1,max_depth+1):
          if d == 1:
              ax = plt.subplot(max_depth,1,d)
          else:
              ax = plt.subplot(max_depth,1,d, sharex = ax)
          ax.set_title(theorem_name + ' expansion #'+str(d))
          tree = theoremNameToLists(theorem_name, depth=d, debug=debug)
          ax.plot(countNodesAtDepths(replaceDefinitions(tree)))
          ax.set_xlabel('Tree Depth (Distance from Root)')
          ax.set_ylabel('Number of Nodes')
          #else:
          #    ax.plot(countNodesAtDepths(tree)[1:], '_', label='No substitution')
          #    ax.plot(countNodesAtDepths(replaceDefinitions(tree)), '|', label='Defn substitution')
          fig.tight_layout()
          #ax.legend()
          #if d != max_depth:
          #    plt.setp(ax.get_xticklabels(), visible=False)
      plt.savefig(f)

def depthToNumNodes(depth, theorem_name):
   tree = theoremNameToLists(theorem_name, depth=depth)
   substitutionTree = replaceDefinitions(tree)
   return countNodes(substitutionTree)

def plotNodesVExtractionDepth(theorem_name, max_depth, figsize = (6,6)):
   f = 'Images/'+theorem_name+'_extraction_depth_'+str(max_depth)+'.png'
   if not os.path.isfile(f):
       fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
       depth_list = list(range(1,max_depth+1))
       #log_depth_list = list(map(lambda x: math.log(x), depth_list))
       num_nodes = list(map(lambda depth: depthToNumNodes(depth, theorem_name), depth_list))
       axs.plot(depth_list, num_nodes, 'r+')
       axs.set_title('Substitution Tree # Nodes Vs Extraction Depth')
       axs.set_xlabel('Extraction Depth')
       axs.set_ylabel('Number of Nodes')
       #axs[1][1].plot(log_depth_list, list(map(lambda x: math.log(x), sub_tree_num_nodes)))
       #axs[1][1].set_xlabel('Log Extraction Depth')
       fig.tight_layout()
       plt.savefig(f)


 #+END_SRC

#+RESULTS:

** Plot num nodes at particular tree depths
*** ev_4

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_4'
    max_depth = 3
    plotNodesVTreeDepth(theorem_name,max_depth=max_depth)
    'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_4_tree_depth_3.png]]
file:Images/ev_4_tree_depth_3.png]]

*** ev_8

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    max_depth = 3
    plotNodesVTreeDepth(theorem_name,max_depth=max_depth)
    'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_tree_depth_3.png]]
file:Images/ev_8_tree_depth_3.png]]

*** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2_not_rational'
    max_depth = 4
    #plotNodesVTreeDepth(theorem_name,max_depth=max_depth)
    'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_tree_depth_4.png]]
file:Images/sqrt2_not_rational_tree_depth_4.png]]

*** birthday_paradox

 #+BEGIN_SRC python :session :results file
     theorem_name = 'birthday_paradox'
     max_depth = 4
     #plotNodesVTreeDepth(theorem_name, max_depth=max_depth)
     'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
 #+END_SRC

 #+RESULTS:
 [[file:Images/birthday_paradox_tree_depth_4.png]]

*** bertrand_ballot

#+BEGIN_SRC python :session :results file
    theorem_name = 'bertrand_ballot'
    max_depth = 3
    #plotNodesVTreeDepth(theorem_name, max_depth=max_depth)
    'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
#+END_SRC

 #+RESULTS:
 [[file:Images/bertrand_ballot_tree_depth_3.png]]

*** Plot num nodes of the tree at particular extraction depths
**** ev_8

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    max_depth = 3
    plotNodesVExtractionDepth(theorem_name,max_depth=max_depth)
    'Images/'+theorem_name+'_extraction_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_extraction_depth_3.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2_not_rational'
    max_depth = 3
    plotNodesVExtractionDepth(theorem_name,max_depth=max_depth)
    'Images/'+theorem_name+'_extraction_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_extraction_depth_3.png]]

**** birthday_paradox

#+BEGIN_SRC python :session :results file
    theorem_name = 'birthday_paradox'
    max_depth = 3
    #plotNodesVExtractionDepth(theorem_name, max_depth=max_depth)
    'Images/'+theorem_name+'_extraction_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_extraction_depth_3.png]]

**** bertrand_ballot

#+BEGIN_SRC python :session :results file
    theorem_name = 'bertrand_ballot'
    max_depth = 3
    #plotNodesVExtractionDepth(theorem_name, max_depth=max_depth)
    'Images/'+theorem_name+'_extraction_depth_'+str(max_depth)+'.png'
#+END_SRC

#+RESULTS:
[[file:Images/bertrand_ballot_extraction_depth_3.png]]

*** Plot subtree sizes

**** Utilities

#+BEGIN_SRC python :session :results output silent

    def getTreeSize(tree):
        c = 0
        for x in tree:
            if isinstance(x,list):
                c += getTreeSize(x)
            else:
                c += 1
        return c

    def createSubtreeSizePlot(theorem_name, max_depth, num_bins=10, debug=False):
        f = 'Images/'+theorem_name+'_subtree_sizes.png'
        if not os.path.isfile(f):
            fig, axs = plt.subplots(max_depth, 1, sharex = True, figsize=(6,6))
            for depth in range(1,max_depth+1):
                tree = theoremNameToLists(theorem_name, depth=depth)
                if debug:
                    printTree(tree)
                distrib = list(map(getTreeSize, tree[1:]))
                if max_depth > 1:
                    axs[depth-1].hist(distrib, bins=num_bins)
                    axs[depth-1].set_title(theorem_name + ' subtree sizes at depth ' + str(depth))
                else:
                    axs.hist(distrib, bins=num_bins)
                    axs.set_title(theorem_name + ' subtree sizes at depth ' + str(depth))
                #print(distrib)
            plt.savefig(f)

#+END_SRC

**** ev_4

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_4'
    createSubtreeSizePlot(theorem_name, max_depth=3)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_4_subtree_sizes.png]]

The two subtrees just happen to be the same size for ev_4 at extraction depth 2.

**** ev_8

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    createSubtreeSizePlot(theorem_name, max_depth=3)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_subtree_sizes.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2_not_rational'
    #createSubtreeSizePlot(theorem_name, max_depth=5, num_bins=40)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_subtree_sizes.png]]

Massive outliers are inherent.

** Create Dependency Graph of Theorems
*** Graph plotting utils
**** Dependency graph for a single root theorem

Goal: given a collection of theorems, create the list of theorems that they reference.
 Then use these theorems and lists to generate a directed graph.

How to deal with extraction depth?
 Use only extraction depth 1.
 This way we only generate the graph of "local" dependencies

How to start?
 Use ev_4 and ev_8. There should be a dependencies from ev_8 to ev_4.
 Then move on to standard library.

#+BEGIN_SRC python :session :results output silent

def theoremToDependencyDict(theorem):
    assert(theorem[0] == 'Top')
    theorem_to_dependencies = {}
    top, theorem_trees = theorem[0], theorem[1:]
    lemma_candidates = list(map(lambda x: x[1], theorem_trees))
    old_frontier_theorem_indices = [0]
    while old_frontier_theorem_indices:
        new_frontier_theorem_indices = []
        for theorem_i in old_frontier_theorem_indices:
            theorem_name = lemma_candidates[theorem_i]
            dependencies = allAtLeaves(lemma_candidates[max(old_frontier_theorem_indices)+1:],
                                       theorem_trees[theorem_i])
            theorem_to_dependencies[theorem_name] = dependencies
            new_frontier_theorem_indices.extend(
                list(map(lambda x: lemma_candidates.index(x), dependencies)))
        old_frontier_theorem_indices = new_frontier_theorem_indices.copy()
    #print(theorem_to_dependencies)
    return {k:set(v) for k,v in theorem_to_dependencies.items()}

def theoremToDependencyGraph(theorem):
    return nx.DiGraph(theoremToDependencyDict(theorem))

assert(theoremToDependencyDict(
           ['Top', ['Def','a','b'], ['Def','b',['c','d']]])
      == {'a':{'b'}, 'b':set()})

assert(theoremToDependencyDict(
            ['Top', ['Def','a','b'], ['Def','b',['App','c','d']], ['Def','c','e'], ['Def','d','e']]
       )
       == {'a':{'b'},'b':{'c','d'},'c':set(),'d':set()})

#+END_SRC

#+RESULTS:


**** Dependency graph for a list of theorems

#+BEGIN_SRC python :session :results output silent

def mergeDicts(d1,d2):
    merged_dict = {}
    k1, k2 = set(d1.keys()), set(d2.keys())
    for k in k1.union(k2):
        if k in k1 and k in k2:
            merged_dict[k] = d1[k].union(d2[k])
        elif k in k1:
            merged_dict[k] = d1[k]
        elif k in k2:
            merged_dict[k] = d2[k]
    return merged_dict

def theoremListToDependencyDict(theorem_list):
    dep_dicts = list(map(lambda theorem: theoremToDependencyDict(theorem), theorem_list))
    return functools.reduce(mergeDicts, dep_dicts, {})

def theoremListToDependencyGraph(theorem_list):
    return nx.DiGraph(theoremListToDependencyDict(theorem_list))

d1 = {'a':{'b'}, 'b':{}}
d2 = {'a':{'b'},'b':{'c','d'},'c':set(),'d':set()}
assert(mergeDicts(d1,{}) == d1)
assert(mergeDicts({},d1) == d1)

theorem_list =  \
    [
        ['Top', ['Def','a','b'], ['Def','b',['c','d']]],
        ['Top',
                ['Def','a','b'], ['Def','b',['App','c','d']], ['Def','c','e'], ['Def','d','e']
        ]
    ]

assert(theoremListToDependencyDict(theorem_list) == d2)

#+END_SRC

**** Plot/Export graph for non-library theorems

#+BEGIN_SRC python :session :results output silent

def plotDependencyGraph(graph, outfile, label=False, figsize=(4,4)):
    assert(graph.order() != 0)
    plt.figure(figsize=figsize)
    nx.spring_layout(graph, k=5/math.sqrt(graph.order()))
    nx.draw(graph, with_labels=label, node_size = 50)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)

def theoremNameToOutfile(theorem_name):
    return 'Images/' + theorem_name + '_dependencies.png'

def exportIndivResults(theorem_name, theorem, graph, depth):
    list_outfolder = "./ProofList/Individual/" + theorem_name
    graph_outfolder = "./Graphs/Individual/" + theorem_name
    if not os.path.exists(list_outfolder):
        os.mkdir(list_outfolder)
    if not os.path.exists(graph_outfolder):
        os.mkdir(graph_outfolder)
    with open(list_outfolder + "/d"+str(depth)+".txt",'w') as f:
        f.write(json.dumps(theorem))
    nx.write_adjlist(graph, graph_outfolder + "/d"+str(depth)+".txt")

def plotDepGraphFromTheoremName(theorem_name, depth=2, label=False, figsize=(4,4), export=False):
    outfile = theoremNameToOutfile(theorem_name)
    if not os.path.exists(outfile):
        theorem = theoremNameToLists(theorem_name, depth=depth)
        graph = theoremToDependencyGraph(theorem)
        if export:
            exportIndivResults(theorem_name, theorem, graph, depth)
        plotDependencyGraph(graph, outfile, label=label, figsize=figsize)


#+END_SRC

**** Plot/Export graph for library theorems

#+BEGIN_SRC python :session :results output silent

def libTheoremNameToLists(theorem_name, library_name, debug=False):
    theorem_location = './ProofTrees/StdLib/'+library_name
    with open(theorem_location + '/'+theorem_name+'.txt', 'r') as f:
        paren_string = f.read()
    if paren_string:
        return parenStringToLists('(Top ' + paren_string.strip() + ')', debug=debug)
    else:
        return []

def nameToStdLibTheorems(library_name, debug=False, limit=None):
    lib_location = "./ProofTrees/StdLib/" + library_name
    if not os.path.exists(lib_location):
        subprocess.run(["./lib_to_trees.sh", library_name])
    theorem_names = list(map(lambda x: x[:-4], os.listdir(lib_location)))
    if limit:
        theorem_names = theorem_names[:limit]
    theorems = {}
    for theorem_name in theorem_names:
        unsub_theorem_def = libTheoremNameToLists(theorem_name, library_name, debug=debug)
        if unsub_theorem_def != []:
            theorems[theorem_name] = unsub_theorem_def
    return theorems

def libNameToOutfile(library_name):
    return 'Images/' + library_name + '_library_dependencies.png'

def exportLibResults(library_name, theorems, graph, depth):
    list_outfolder = "./ProofList/StdLib/" + library_name
    graph_outfolder = "./Graphs/StdLib/" + library_name
    if not os.path.exists(list_outfolder):
        os.mkdir(list_outfolder)
    if not os.path.exists(graph_outfolder):
        os.mkdir(graph_outfolder)
    for theorem_name, theorem_def in theorems.items():
        with open(list_outfolder + '/' + theorem_name + '.txt','w') as f:
            f.write(json.dumps(theorem_def))
    nx.write_adjlist(graph, graph_outfolder + '/' + library_name + '.txt')


def plotDepGraphFromLibraryName(library_name, depth=2, label=False, figsize = (8,6), export=False, debug=False):
    assert(library_name in os.listdir('/home/scottviteri/LocalSoftware/coq/theories'))
    outfile = libNameToOutfile(library_name)
    if not os.path.exists(outfile):
        theorems = nameToStdLibTheorems(library_name, debug=debug)
        graph = theoremListToDependencyGraph(theorems.values())
        if export:
            exportLibResults(library_name, theorems, graph, depth)
        plotDependencyGraph(graph, outfile, label=label, figsize=figsize)

#+END_SRC

#+RESULTS:

*** Plot dependency graphs for non-library theorems

**** ev_8

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
plotDepGraphFromTheoremName(theorem_name, label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_dependencies.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
plotDepGraphFromTheoremName(theorem_name, figsize = (8,6), label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_dependencies.png]]

**** birthday_paradox

#+BEGIN_SRC python :session :results file
theorem_name = 'birthday_paradox'
plotDepGraphFromTheoremName(theorem_name, figsize = (8,6),label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_dependencies.png]]


Hypothesis about what is going on here:
 Library theorems have many more direct dependencies than the average Coq proof

**** bertrand_ballot

#+BEGIN_SRC python :session :results file
theorem_name = 'bertrand_ballot'
#plotDepGraphFromTheoremName(theorem_name, figsize = (8,6), label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/bertrand_ballot_dependencies.png]]

*** Plot dependency graphs for libraries

**** Reals

#+BEGIN_SRC python :session :results file
library_name = "Reals"
#plotDepGraphFromLibraryName(library_name)
#libNameToOutfile(library_name)
#+END_SRC

#+RESULTS:

**** Arith

#+BEGIN_SRC python :session :results file
library_name = "Arith"
#plotDepGraphFromLibraryName(library_name)
#libNameToOutfile(library_name)
#+END_SRC

#+RESULTS:

**** ZArith

#+BEGIN_SRC python :session :results file
library_name = "ZArith"
#plotDepGraphFromLibraryName(library_name)
#libNameToOutfile(library_name)
#+END_SRC

#+RESULTS:

** Create Substituted Theorem Graphs
*** Tree to DAG utils

#+BEGIN_SRC python :session :results output silent

# convert non-unique, ordered to unique, unordered

def genSample():
    x = replaceDefinitions(ev_4_tree)
    trees = ['Top',x,x.copy()]
    trees[2][1] = 'ev_4.ev_4_2'
    return trees

dup_ev_4_tree = genSample()

def countMatches(subtree, tree): #could make efficient by only doing to 2
    if subtree == tree:
        return 1
    if not isinstance(tree,list):
        return 0
    count = 0
    for x in tree[1:]:
        if x == subtree:
            count += 1
        else:
            count += countMatches(subtree, x)
    return count

assert(countMatches(3, ['a','b',[1,3,4]]) == 1)

ab_list = ['Top', ['Def',['a','b'],['a','b']], ['Def',['a','b']]]
assert(countMatches(['a','b'], ab_list) == 3)

def locateMatches(subtree, tree):
    """ Get locations of matches, as index list
    Base: locateMatches(['a','b'], ['Def',['a','b'],['a','b']]) -> [[1],[2]]
    Ind: locateMatches(['a','b'], ['Top', [1,2], [1]]) -> [[1,1], [1,2], [2,1]]
    """
    assert(subtree != tree)
    #assert(isinstance(tree,list))
    locations = []
    for i in range(1,len(tree)):
        x = tree[i]
        if x == subtree:
            locations.append([i])
        else:
            if isinstance(x, list):
                locations.extend([[i] + y for y in locateMatches(subtree, x)])
    return locations

assert(locateMatches(3, ['a','b',[1,3,4]]) == [[2,1]])
assert(locateMatches(['a','b'], ab_list) == [[1, 1], [1, 2], [2, 1]])
assert(locateMatches('2',['Def','d2'])==[])
assert(locateMatches('2', ['Top', ['Def', 'd1', ['App', '2', '3']], ['Def', 'd2']])
        == [[1,2,1]])

#+END_SRC python :session :results output silent

#+BEGIN_SRC python :session :results output silent

def removeSubtreeEffect(subtree, tree):
    while 1:
        for i in range(1,len(tree)):
            next_tree = tree[i]
            if subtree == next_tree:
                del tree[i]
            else:
                removeSubtree(subtree, next_tree)
        return

def removeSubtree(subtree, tree):
    if not isinstance(tree, list):
        return tree
    h,t = tree[0], tree[1:]
    l = [h]
    for x in t:
        if subtree == x:
            continue
        else:
            l.append(removeSubtree(subtree, x))
    return l

assert(removeSubtree(['a','b'], ab_list) == ['Top', ['Def'], ['Def']])

def getLeaves(tree):
    leaves = []
    for x in tree[1:]:
        if not isinstance(x,list):
            leaves.append(x)
        else:
            leaves.extend(getLeaves(x))
    return leaves

assert(getLeaves(ev_4_tree) ==
       ['ev_4.ev_4', 'ev_SS', '2', 'ev_4.ev_2', 'ev_4.ev_2', 'ev_SS', 'O', 'ev_0']
)


def getTheoremLeaves(tree):
    top, defs = tree[0], tree[1:]
    all_leaves = map(getLeaves, [x[2] for x in defs if len(x) >= 3])
    return functools.reduce(lambda x,y: x+y, all_leaves, [])

assert(getTheoremLeaves(ev_4_tree) ==
    ['ev_SS', '2', 'ev_4.ev_2', 'ev_SS', 'O', 'ev_0']
)

#+END_SRC

#+BEGIN_SRC python :session :results output silent

#def compressTrees(trees, new_theorem_name='th0'):
#    frontier = [trees]
#    index_list = []
#    while frontier:
#        index_count = 0
#        current_node = frontier.pop(0)
#        if isinstance(current_node, list):
#            name = current_node[0]
#            for i in range(1,len(current_node)):
#                match_tree = current_node[i]
#                if isinstance(match_tree, list):
#                    num_matches = countMatches(match_tree, trees)
#                    if num_matches >= 2:
#                        match_locations = locateMatches(match_tree, trees)
#                        match_theorem_names = [trees[loc[0]][1] for loc in match_locations]
#                        compressed_tree = replaceVal(trees, match_tree, new_theorem_name)
#                        compressed_tree.append(['Definition', new_theorem_name, match_tree])
#                        #compressed_tree = removeSubtree(match_tree, trees)
#                        return match_tree, match_theorem_names, compressed_tree
#        frontier.extend(current_node[1:])
#        index_list.append(index_count)
#    return (None, None, trees)

def compressTrees(trees, new_theorem_name='th0'):
    frontier = [trees]
    index_list = []
    all_matches = []
    while frontier:
        index_count = 0
        current_node = frontier.pop(0)
        if isinstance(current_node, list):
            name = current_node[0]
            for i in range(1,len(current_node)):
                match_tree = current_node[i]
                if isinstance(match_tree, list) :
                    num_matches = countMatches(match_tree, trees)
                    if num_matches >= 2:
                        all_matches.append((match_tree, num_matches*countNodes(match_tree)))
            frontier.extend(current_node[1:])
            index_list.append(index_count)

    if all_matches:
        match_tree = max(all_matches, key=lambda x:x[1])[0]
        match_locations = locateMatches(match_tree, trees)
        match_theorem_names = [trees[loc[0]][1] for loc in match_locations]
        compressed_tree = replaceVal(trees, match_tree, new_theorem_name)
        compressed_tree.append(['Definition', new_theorem_name, match_tree])
        #compressed_tree = removeSubtree(match_tree, trees)
        return match_tree, match_theorem_names, compressed_tree

    #print('all_matches', all_matches)
    return (None, None, trees)


def labelLeaves(trees):
    # extract leaves
    leaves_to_theorems = {}
    leaves = set(getTheoremLeaves(trees))
    for leaf in leaves:
        match_locations = locateMatches(leaf, trees)
        match_theorem_names = [trees[loc[0]][1] for loc in match_locations]
        leaves_to_theorems[leaf] = match_theorem_names
    return leaves_to_theorems


def substTreesToDepGraph(trees):
    depends_on = {k[1]:set() for k in trees[1:]}
    contents = {}
    match_tree = True
    match_count = 0
    while match_tree is not None: #repeat until no matches
        new_theorem_name = 'th' + str(match_count)
        (match_tree, match_names, trees) = compressTrees(trees, new_theorem_name)
        if match_tree:
            contents[new_theorem_name] = match_tree
            for match_name in match_names:
                depends_on[match_name].add(new_theorem_name)
            #trees.append(['Definition',new_theorem_name, match_tree])
            depends_on[new_theorem_name] = set()
        match_count += 1
    #if not contents:
    #    contents = {k[1]:k[2] for k in trees[1:]}
    contents = {k[1]:k[2] for k in trees[1:]}
    return depends_on, contents

#+END_SRC

#+BEGIN_SRC python :session :results output silent

def plotDependencyGraphs(g1, g2, outfile, label=False, figsize=(4,4)):
    if not os.path.exists(outfile):
        fig, axs = plt.subplots(1,2,figsize=figsize)
        nx.spring_layout(g1, k=5/math.sqrt(g1.order()))
        nx.draw(g1, ax=axs[0], with_labels=label, node_size = 50)
        nx.spring_layout(g2, k=5/math.sqrt(g2.order()))
        nx.draw(g2, ax=axs[1], with_labels=label, node_size = 50)
        range1,range2 = axs[0].get_xlim(), axs[1].get_xlim()
        axs[0].set_xlim(range1[0]-0.2, range1[1]+0.2)
        axs[1].set_xlim(range2[0]-0.2, range2[1]+0.2)
        plt.savefig(outfile)

def plotDependencyGraphList(g_list, outfile, label=False):
    figsize = (6,3*len(g_list))
    fig, axs = plt.subplots(len(g_list),1,figsize=figsize)
    for i in range(len(g_list)):
        g, ax = g_list[i], axs[i]
        nx.spring_layout(g, k=5/math.sqrt(g.order()))
        nx.draw(g, ax=ax, with_labels=label, node_size = 50)
        range1 = ax.get_xlim()
        ax.set_xlim(range1[0]-0.2, range1[1]+0.2)
    plt.savefig(outfile)

def wrap(y):
    return {k:[v] if not isinstance(v,list) else v for k,v in y.items()}

#+END_SRC

*** Tree to DAG util examples

#+BEGIN_SRC python :session :results output silent

t1 = ['Top',['Def','d1',['App','2','2']],['Def','d2',['App','2','2']]]
assert(substTreesToDepGraph(t1) ==
    ({'d1': {'th0'}, 'd2': {'th0'}, 'th0': set()},
     {'d1': 'th0', 'd2': 'th0', 'th0': ['App', '2', '2']}))

t2 = ['Top',['Def','d1',['App','2','2']],['Def','d2','2']]
assert(substTreesToDepGraph(t2) ==
        ({'d1': set(), 'd2': set()}, {'d1': ['App', '2', '2'], 'd2': '2'}))

t3 = ['Top',['Def','d1',['App','2','3',['App','2','2']]],['Def','d2',['App','2','2']]]
assert(substTreesToDepGraph(t3) ==
        ({'d1': {'th0'}, 'd2': {'th0'}, 'th0': set()},
         {'d1': ['App', '2', '3', 'th0'], 'd2': 'th0', 'th0': ['App', '2', '2']}))

t4 = ['Top',
        ['Def', 'd1', ['App', ['App', '2', '2'], ['App', '2', '2']]],
        ['Def', 'd2', ['App', ['App', '2', '2'], ['App', '2', '2']]]]
assert(substTreesToDepGraph(t4) ==
        ({'d1': {'th0'}, 'd2': {'th0'}, 'th0': {'th1'}, 'th1': set()},
         {'d1': 'th0', 'd2': 'th0', 'th0': ['App', 'th1', 'th1'], 'th1': ['App', '2', '2']}))


#+END_SRC

*** Tree to DAG for indiv theorems

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_4_gen_dep_graph.png'
x,y = substTreesToDepGraph(['Top',replaceDefinitions(ev_4_tree)])
plotDependencyGraph(nx.DiGraph(x), outfile,label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_4_gen_dep_graph.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_gen_dep_graph.png'
x,y = substTreesToDepGraph(['Top', replaceDefinitions(ev_8_alt_tree)])
plotDependencyGraph(nx.DiGraph(x),
                      outfile, label=True, figsize=(4,4))

print()
for k,v in wrap(y).items():
    print(k)
    printTree(v,4)
    print()

outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_gen_dep_graph.png]]

*** Tree to DAG for library theorems

#+BEGIN_SRC python :session :results output silent
def nameToStdLibTheoremPairs(library_name, debug=False):
    lib_location = "./ProofTrees/StdLib/" + library_name
    if not os.path.exists(lib_location):
        subprocess.run(["./lib_to_trees.sh", library_name])
    theorem_names = list(map(lambda x: x[:-4], os.listdir(lib_location)))
    count = 0
    should_compute = yield
    for theorem_name in theorem_names:
        #print("theorem_name:", theorem_name)
        #print("should_compute:", should_compute)
        if should_compute:
            unsub_theorem_def = libTheoremNameToLists(theorem_name, library_name, debug=debug)
            if unsub_theorem_def != []:
                sub_theorem_def = replaceDefinitions(unsub_theorem_def)
                count += 1
                should_compute = yield((unsub_theorem_def, sub_theorem_def))
        else:
            should_compute = yield


#+END_SRC


#+BEGIN_SRC python :session :results output silent

library_name = 'Arith'
max_num_theorems = 3
theorem_generator = nameToStdLibTheoremPairs(library_name)
next(theorem_generator)
plot = True

theorem_count = 0
unsub_dep_dict = {}
rooted_sub_trees = ['Top']
while theorem_count < max_num_theorems:
    outfile = 'Images/combined_dep_graphs_'+str(theorem_count)+'.png'
    sub_dict_loc = 'Graphs/UnsubSub/'+library_name+'_sub_'+str(theorem_count)+'.json'
    sub_theorems_loc = 'Graphs/UnsubSub/'+library_name+'_sub_'+str(theorem_count)+'_theorems.json'
    unsub_loc = 'Graphs/UnsubSub/'+library_name+'_unsub_'+str(theorem_count)+'.json'
    if os.path.exists(sub_theorems_loc) and os.path.exists(unsub_loc) and os.path.exists(sub_dict_loc):
        rooted_sub_trees = json.load(open(sub_theorems_loc))
        unsub_dep_dict = {k:set(v) for k,v in json.load(open(unsub_loc)).items()}
        next(theorem_generator)
    else:
        unsub, sub = theorem_generator.send(True) #add a theorem to the pool
        # add new unsub dependency dict to the previous
        unsub_dep_dict = mergeDicts(unsub_dep_dict, theoremToDependencyDict(unsub))
        print(unsub_dep_dict)
        # accumuluate sub tree output of theorem generator
        rooted_sub_trees.append(sub)
        with open(sub_theorems_loc,'w') as f:
           f.write(json.dumps(rooted_sub_trees))
        # create subst tree dependency dict, save
        sub_dep_dict, sub_dep_contents = substTreesToDepGraph(rooted_sub_trees)
        print(sub_dep_dict)
        with open(sub_dict_loc,'w') as f:
            f.write(json.dumps({k:list(v) for k,v in sub_dep_dict.items()}))
        with open('Graphs/UnsubSub/'+library_name+'_sub_'+str(theorem_count)+'_contents.json','w') as f:
            f.write(json.dumps({k:list(v) for k,v in sub_dep_contents.items()}))
        with open(unsub_loc,'w') as f:
            f.write(json.dumps({k:list(v) for k,v in unsub_dep_dict.items()}))
        # plot results
        sub_dep_dict = substTreesToDepGraph(rooted_sub_trees)[0]
        if plot:
            plotDependencyGraphs(nx.DiGraph(unsub_dep_dict),
                                 nx.DiGraph(sub_dep_dict), outfile, figsize=(8,6))
    theorem_count += 1

outfile
#+END_SRC

#+RESULTS:
[[file:Images/combined_dep_graphs_2.png]]

#+BEGIN_SRC python :session :results file

library_name = "Arith"
lib_location = "./Graphs/UnsubSub"
outfile = "Images/comparison_sizes.png"

#num_theorems = int(len(list(filter(lambda x: 'theorems' not in x and 'contents' not in x,
#                                 filter(lambda y: library_name in y,
#                                        os.listdir(lib_location)))))/2)
##fig, axs = plt.subplots(figsize=(6,6))
#unsub_num_nodes = []
#sub_num_nodes = []
#for i in range(num_theorems):
#    unsub_loc = 'Graphs/UnsubSub/'+library_name+'_unsub_'+str(i)+'.json'
#    sub_loc = 'Graphs/UnsubSub/'+library_name+'_sub_'+str(i)+i.json'
#    with open(unsub_loc,'r') as f:
#        unsub_graph = nx.DiGraph({k:set(v) for k,v in json.load(f).items()})
#    with open(sub_loc,'r') as f:
#        sub_graph = nx.DiGraph({k:set(v) for k,v in json.load(f).items()})
#    unsub_num_nodes.append(nx.number_of_nodes(unsub_graph))
#    sub_num_nodes.append(nx.number_of_nodes(sub_graph))
#
#fig, axs = plt.subplots(1,1,figsize=(4,4))
#axs.plot(range(1,num_theorems+1), unsub_num_nodes, 'r', label='unsubst graph')
#axs.plot(range(1,num_theorems+1), sub_num_nodes, 'b', label='subst graph')
#axs.set_title('Size Dependency Graph v Num Theorems')
#axs.set_xlabel('Num input theorems ('+library_name+')')
#axs.set_ylabel('Num theorems in dependency graph')
#axs.legend()
#fig.tight_layout()
#plt.savefig(outfile)

outfile
#+END_SRC

#+RESULTS:
[[file:Images/comparison_sizes.png]]


#+BEGIN_SRC python :session :results file

library_name = "Arith"
lib_location = "./Graphs/UnsubSub"
outfile = "Images/comparison_degree_dist.png"

num_theorems = int(len(list(filter(lambda x: 'theorems' not in x and 'contents' not in x,
                                 filter(lambda y: library_name in y,
                                        os.listdir(lib_location)))))/2)
#fig, axs = plt.subplots(figsize=(6,6))
fig, axs = plt.subplots(num_theorems, 2, sharex=True, sharey=True, figsize=(6,8))

for i in range(num_theorems):
    unsub_loc = lib_location+'/'+library_name+'_unsub_'+str(i)+'.json'
    sub_loc = lib_location+'/'+library_name+'_sub_'+str(i)+'.json'
    with open(unsub_loc,'r') as f:
        unsub_graph = nx.DiGraph({k:set(v) for k,v in json.load(f).items()})
    with open(sub_loc,'r') as f:
        sub_graph = nx.DiGraph({k:set(v) for k,v in json.load(f).items()})
    unsub_ax, sub_ax = axs[i][0], axs[i][1]
    unsub_hist, sub_hist = nx.degree_histogram(unsub_graph), nx.degree_histogram(sub_graph)
    unsub_ax.plot(range(len(unsub_hist)), unsub_hist)
    sub_ax.plot(range(len(sub_hist)), sub_hist)
    if i == 0:
        unsub_ax.set_title('Unsubstituted theorems')
        sub_ax.set_title('Substituted theorems')

fig.tight_layout()
plt.savefig(outfile)

outfile
#+END_SRC

#+RESULTS:
[[file:Images/comparison_degree_dist.png]]
** Develop Alternate Notion of Dependency Graph
*** Convert individual theorem tree to graph

#+BEGIN_SRC python :session :results output silent

cic_constructors = ['Definition', 'Axiom', 'App', 'Lambda',
                    'Cast', 'LetIn','Fix','CoFix',
                    'CaseMatch', 'CaseBranches','Sort',
                    'Prod','Inductive','Case','CoInductive',
                    'Record','VMCast','DEFAULTcast','REVERTcast',
                    'NATIVEcast','Var','Meta','Evar','Rel','Level',
                    'Max','Universe','UnivInstance','Sort','Prop','Type',
                    'Functions','Proj','Name','Anonymous']


def constructorMatch(test, constructor):
    return constructor == test[:len(constructor)]

assert(constructorMatch('App1','App'))
assert(not constructorMatch('App','App1'))

def whichConstructor(test):
    matching_constrs = list(filter(lambda x: constructorMatch(test, x), cic_constructors))
    if matching_constrs:
        return matching_constrs[0]
    return None

assert(whichConstructor('App1') == 'App')
assert(whichConstructor('Lambda2') == 'Lambda')
assert(whichConstructor('Cast') == 'Cast')


def isConstructor(test):
    matching_constrs = list(filter(lambda x: constructorMatch(test, x), cic_constructors))
    return len(matching_constrs) == 1

assert(isConstructor('App1'))
assert(isConstructor('Lambda2'))
assert(isConstructor('Cast'))

def isShallowSubgraph(dag1, dag2):
    constructor, children = list(dag1.items())[0]
    for k2 in dag2:
        if isConstructor(k2) and constructorMatch(k2, constructor) and children == dag2[k2]:
            return k2
    return False

assert(isShallowSubgraph({'App':{'1','2'}}, {'App1':{'1','2'}}) == 'App1')
assert(not isShallowSubgraph({'App':{'1','2'}}, {'App1':{'1','3'}}))

#+END_SRC


#+BEGIN_SRC python :session :results output

def convToDAG(tree, out_dag = {}, cic_count = {constr: 0 for constr in cic_constructors}):
    if not isinstance(tree, list):
        out_dag[tree] = set()
        return out_dag, tree, cic_count
    else:
       root, children = tree[0], tree[1:]
       mod_child_names = []
       for child in children:
           out_dag, name, cic_count = convToDAG(child, out_dag, cic_count)
           mod_child_names.append(name)
       new_dag = {root: set(mod_child_names)}
       root_new = isShallowSubgraph(new_dag, out_dag)
       if not root_new:
           cic_count[root] += 1
           root_new = root + str(cic_count[root])
           out_dag[root_new] = set(mod_child_names)
    return out_dag, root_new, cic_count

def toDAG(tree):
    dag, rt_name, cic_count = convToDAG(tree, {}, {constr: 0 for constr in cic_constructors})
    return dag

def checkEq(d1, d2):
    if d1.keys() != d2.keys():
        return False
    for k in d1:
        if d1[k] != d2[k]: return False
    return True


a = ['App','2','2']
b = ['App','2',a]
c = ['App',b,b]

# did we want this (App3)?
assert(checkEq(toDAG(c),
               {'2': set(), 'App1': {'2'}, 'App2': {'2', 'App1'}, 'App3': {'App2'}}))

assert(checkEq(
        toDAG(ev_4_tree[1][2]),
        {'ev_SS': set(), '2': set(), 'ev_4.ev_2': set(), 'App1': set(['ev_SS', '2', 'ev_4.ev_2'])}))

assert(checkEq(toDAG(['App',['App','2','2'],['App','2','2']]),
               {'2': set(), 'App1': {'2'}, 'App2': {'App1'}}))

assert(checkEq(
        toDAG(['App', ['App', '2', '2'], ['App', '2', ['App', '2', '2']]]),
        {'2': set(), 'App1': {'2'}, 'App2': {'App1', '2'}, 'App3': {'App2', 'App1'}}
       ))

#+END_SRC

#+RESULTS:
   {'App3': {'App', '2'}}, {'App4': {'App3', 'App2'}}]

*** Convert entire theorem tree to DAG

#+BEGIN_SRC python :session :results output silent

def theoremsToDAG(top_level_theorem, theorem_name=None, ordered=False):
    outfile = './ProofDAGs/Individual/'+theorem_name+'_dag.txt' if theorem_name else None
    if outfile and os.path.exists(outfile):
        return {k:set(v) for k,v in json.load(open(outfile)).items()}
    else:
        dag = {}
        cic_count = {constr: 0 for constr in cic_constructors}
        count = 0
        for tree in top_level_theorem[1:]:
            lemma_name, lemma_def = tree[1], tree[2]
            if ordered:
                dag, lemma_root, cic_count = convToDAGOrdered(lemma_def, dag.copy(), cic_count.copy())
            else:
                dag, lemma_root, cic_count = convToDAG(lemma_def, dag.copy(), cic_count.copy())
            if count >= 1:
                dag.pop(lemma_name, None)
                for k,v in dag.items():
                    if lemma_name in v:
                        dag[k] = {x if x != lemma_name else lemma_root for x in v}
            else:
                theorem_name = lemma_name
            count += 1
        if outfile is not None:
            with open(outfile,'w') as f:
                f.write(json.dumps({k:list(v) for k,v in dag.items()}))
        return dag

assert(theoremsToDAG(ev_4_tree)
        == {'ev_SS': set(), '2': set(), 'App1': {'2', 'App2', 'ev_SS'}, 'O': set(),
            'ev_0': set(), 'App2': {'ev_0', 'O', 'ev_SS'}})


#+END_SRC

*** Plot theorem DAG's
**** ev_4

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_4'
g = nx.DiGraph(theoremsToDAG(ev_4_tree, theorem_name))
plotDependencyGraph(g,'./Images/'+theorem_name+'_DAG.png',label=True)
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_DAG.png]]

**** ev_8

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
g = nx.DiGraph(theoremsToDAG(ev_8_tree, theorem_name))
plotDependencyGraph(g, './Images/'+theorem_name+'_DAG.png', label=True)
'./Images/ev_8_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_DAG.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
outfile = './Images/'+theorem_name+'_DAG.png'
#g = nx.DiGraph(theoremsToDAG(sqrt2_tree ,theorem_name))
#plotDependencyGraph(g, outfile, label=True, figsize=(8,8))
'./Images/'+theorem_name+'_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_DAG.png]]

*** Generate random replica DAG's with same arities

#+BEGIN_SRC python :session :results file

ev_4_dag = theoremsToDAG(ev_4_tree)
ev_8_dag = theoremsToDAG(ev_8_tree)

def anyIncomingEdges(node, graph):
    return any([node in v for v in graph.values()])

def randomTopSort(theorem_dag):
    dag = copy.deepcopy(theorem_dag)
    L = []
    S = {k for k in dag if not anyIncomingEdges(k, dag)}
    while S:
        n = S.pop()
        L.append(n)
        neighbors = dag[n].copy()
        for m in random.sample(neighbors, len(neighbors)):
            dag[n].remove(m)
            if not anyIncomingEdges(m, dag):
                S.add(m)
    return L

def getDownStream(node, graph):
    out = []
    frontier = [node]
    while frontier:
        current_node = frontier.pop(0)
        out.append(current_node)
        frontier.extend(list(graph[current_node]))
    return out


def checkTopOrder(top_order, graph):
    collective_downstream = set()
    for current_node in top_order[::-1]:
        if current_node in collective_downstream:
            return False
        collective_downstream = collective_downstream.union(getDownStream(current_node, graph))
    return True

assert(checkTopOrder(nx.topological_sort(nx.DiGraph(ev_8_dag)), ev_8_dag))
assert(all([checkTopOrder(randomTopSort(ev_8_dag), ev_8_dag) for _ in range(100)]))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results file

def flatten(lst_of_lsts):
    return functools.reduce(lambda x,y: x+y, lst_of_lsts, [])

def genComparableGraph(theorem_dag, test=False):
    #preprocessing
    theorem_nodes = list(theorem_dag.keys())
    name_to_num = {name: num for num, name in enumerate(theorem_nodes)}
    num_to_name = {num: name for num, name in enumerate(theorem_nodes)}
    outgoing_edges = {n: len(theorem_dag[num_to_name[n]])
                         for n in range(len(theorem_nodes))}
    #create random connections that match arities
    top_sort = randomTopSort(theorem_dag)
    if test:
        assert(checkTopOrder(top_sort, theorem_dag)) #errors in here
        assert(outgoing_edges[name_to_num[top_sort[-1]]] == 0)
    new_nodes = [name_to_num[name] for name in top_sort]
    new_graph = {n:set() for n in range(len(theorem_nodes))}
    #first pass
    for i in range(1,len(new_nodes)):
        current_node = new_nodes[i]
        connection_options = flatten([[(parent, edge) for edge in range(outgoing_edges[parent])]
                                        for parent in new_nodes[:i]])
        parent, edge = random.choice(connection_options)
        new_graph[parent].add(current_node)
        outgoing_edges[parent] -= 1
    #leftover edges
    for i in range(len(new_nodes)):
        current_node = new_nodes[i]
        outgoing_left = outgoing_edges[current_node]
        connection_options = new_nodes[i+1:]
        #print(num_to_name[current_node], outgoing_left)
        if outgoing_left <= len(connection_options):
            children = random.sample(connection_options, outgoing_left)
        else:
            children = {random.choice(connection_options) for _ in range(outgoing_left)}
        new_graph[current_node] = new_graph[current_node].union(children)
    return {str(x):set(map(str,y)) for x,y in new_graph.items()}

print(ev_4_dag)
print(genComparableGraph(ev_4_dag))
#print(genComparableGraph(ev_8_dag))

#+END_SRC

#+RESULTS:
[[file:[5, 1, 4]]]
[[file:['App2', 'App1', 'App3', '2', 'ev_8.ev_2', '4', '6', 'ev_SS']]]
[[file:[]]]
[[file:[1, 5, 3]]]
[[file:[(0, 3), (1, 2), (2, 1)]]]
[[file:[(0, 0), (1, 1), (2, 2), (3, 3)]]]
[[file:[0, 2, 3, 1]]]

*** Plot generated replica DAG's
**** ev_4

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_4_gen_DAG.png'
ev_4_dag = theoremsToDAG(ev_4_tree,'ev_4')
gen_ev_4_dag = genComparableGraph(ev_4_dag)
plotDependencyGraphs(nx.DiGraph(ev_4_dag),
                     nx.DiGraph(gen_ev_4_dag), outfile, label=True, figsize=(8,8))

'./Images/ev_4_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_gen_DAG.png]]

**** ev_8

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_8_gen_DAG.png'
ev_8_dag = theoremsToDAG(ev_8_tree,'ev_8')
gen_ev_8_dag = genComparableGraph(ev_8_dag)
plotDependencyGraphs(nx.DiGraph(ev_8_dag),
                     nx.DiGraph(gen_ev_8_dag), outfile, label=True, figsize=(8,8))
'./Images/ev_8_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_gen_DAG.png]]

**** ev_4_alt

#+BEGIN_SRC python :session :results file
outfile = './Images/ev_4_alt_gen_DAG.png'
ev_4_alt_dag = theoremsToDAG(ev_4_alt_tree,'ev_4_alt')
gen_ev_4_alt_dag = genComparableGraph(ev_4_alt_dag)
plotDependencyGraphs(nx.DiGraph(ev_4_alt_dag),
                     nx.DiGraph(gen_ev_4_alt_dag), outfile, label=True, figsize=(8,8))

'./Images/ev_4_alt_gen_DAG.png'
#+END_SRC

#+RESULTS:
[[file:./Images/ev_4_alt_gen_DAG.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
outfile = './Images/'+theorem_name+'_gen_DAG.png'
#sqrt2_dag = theoremsToDAG(sqrt2_tree, 'sqrt2_not_rational')
#gen_sqrt2_dag = genComparableGraph(sqrt2_dag) #P52 in values but not in keys
#plotDependencyGraphs(nx.DiGraph(sqrt2_dag),
#                     nx.DiGraph(gen_sqrt2_dag), outfile, label=False, figsize=(8,8))

outfile
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_gen_DAG.png]]

*** Export multiple replica DAG's
**** Utils

#+BEGIN_SRC python :session :results output silent

def genComparableGraphs(theorem_dag, num_graphs, test=False):
    #preprocessing
    theorem_nodes = list(theorem_dag.keys())
    name_to_num = {name: num for num, name in enumerate(theorem_nodes)}
    num_to_name = {num: name for num, name in enumerate(theorem_nodes)}
    original_outgoing_edges = {n: len(theorem_dag[num_to_name[n]])
                                 for n in range(len(theorem_nodes))}
    #create random connections that match arities
    new_graphs = []
    for _ in range(num_graphs):
        top_sort = randomTopSort(theorem_dag)
        outgoing_edges = copy.deepcopy(original_outgoing_edges)
        if test:
            assert(checkTopOrder(top_sort, theorem_dag)) #errors in here
            assert(outgoing_edges[name_to_num[top_sort[-1]]] == 0)
        new_nodes = [name_to_num[name] for name in top_sort]
        new_graph = {n:set() for n in range(len(theorem_nodes))}
        #first pass
        for i in range(1,len(new_nodes)):
            current_node = new_nodes[i]
            connection_options = flatten([[(parent, edge) for edge in range(outgoing_edges[parent])]
                                            for parent in new_nodes[:i]])
            parent, edge = random.choice(connection_options)
            new_graph[parent].add(current_node)
            outgoing_edges[parent] -= 1
        #leftover edges
        for i in range(len(new_nodes)):
            current_node = new_nodes[i]
            outgoing_left = outgoing_edges[current_node]
            connection_options = new_nodes[i+1:]
            #print(num_to_name[current_node], outgoing_left)
            children = {random.choice(connection_options) for _ in range(outgoing_left)}
            new_graph[current_node] = new_graph[current_node].union(children)
        new_graphs.append(new_graph)
    return new_graphs


def exportReplicas(theorem_dag, theorem_name, num_replicas):
    outfolder = './Graphs/Individual/'+theorem_name+'/'
    if not os.path.exists(outfolder):
        os.mkdir(outfolder)
        nx.write_adjlist(nx.DiGraph(theorem_dag), outfolder+'dag_adjlist.txt')
        gen_dags = genComparableGraphs(theorem_dag, num_replicas)
        for i,g in enumerate(gen_dags):
            G = nx.DiGraph(g)
            nx.write_adjlist(G, outfolder+'gen_dag_adjlist_'+str(i)+'.txt')
            plotDependencyGraph(G, './Images/'+theorem_name+'_gen_DAG_'+str(i)+'.png')

#+END_SRC

**** ev_4

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_4'
dag = theoremsToDAG(ev_4_tree, theorem_name)
exportReplicas(dag, theorem_name, 5)
plotDependencyGraph(nx.DiGraph(dag),'./Images/'+theorem_name+'_orig_DAG.png')
#+END_SRC

**** ev_8

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8'
dag = theoremsToDAG(ev_8_tree, theorem_name)
exportReplicas(dag, theorem_name, 5)
plotDependencyGraph(nx.DiGraph(dag),'./Images/'+theorem_name+'_orig_DAG.png')
#+END_SRC

**** ev_8_alt

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8_alt'
dag = theoremsToDAG(ev_8_alt_tree, theorem_name)
exportReplicas(dag, theorem_name, 10)
plotDependencyGraph(nx.DiGraph(dag),'./Images/'+theorem_name+'_orig_DAG.png')
#+END_SRC

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results output silent
theorem_name = 'sqrt2_not_rational'
#dag = theoremsToDAG(sqrt2_tree, theorem_name)
#exportReplicas(dag, theorem_name, 5)
#plotDependencyGraph(nx.DiGraph(dag),'./Images/'+theorem_name+'_orig_DAG.png')
#+END_SRC

#+BEGIN_SRC python :session :results output silent
theorem_name = 'birthday_paradox'
#bday_tree = theoremNameToLists('birthday_paradox')
#dag = theoremsToDAG(bday_tree, theorem_name)
#exportReplicas(dag, theorem_name, 2)
#plotDependencyGraph(nx.DiGraph(dag),'./Images/'+theorem_name+'_orig_DAG.png')
#+END_SRC


#+BEGIN_SRC python :session :results output silent
theorem_name = 'sqrt2_not_rational_d3'
#tree = theoremNameToLists('sqrt2_not_rational', depth=3)
#dag = theoremsToDAG(tree, theorem_name)
#exportReplicas(dag, theorem_name, 5)
#plotDependencyGraph(nx.DiGraph(dag),'./Images/'+theorem_name+'_orig_DAG.png')
#+END_SRC

*** Basic DAG Analysis Utils

**** Utils

#+BEGIN_SRC python :session :results output silent

def testDAG(g):
    nx.write_adjlist(nx.DiGraph(g), './temp.txt')
    return nx.read_adjlist('./temp.txt', create_using=nx.DiGraph())

def importReplicas(theorem_name):
    in_folder = './Graphs/Individual/'+theorem_name+'/'
    orig = []
    replicas = []
    for f in os.listdir(in_folder):
        dag = nx.read_adjlist(in_folder+f,create_using=nx.DiGraph())
        if 'gen' in f:
            replicas.append(dag)
        else:
            orig.append(dag)
    assert(len(orig) == 1)
    return orig[0], replicas

def nxToDict(graph):
    return {k:set(v) for k,v in nx.to_dict_of_lists(graph).items()}

def importReplicasToDict(theorem_name):
    in_folder = './Graphs/Individual/'+theorem_name+'/'
    orig = []
    replicas = []
    for f in os.listdir(in_folder):
        dag = nxToDict(nx.read_adjlist(in_folder+f,create_using=nx.DiGraph()))
        if 'gen' in f:
            replicas.append(dag)
        else:
            orig.append(dag)
    assert(len(orig) == 1)
    return orig[0], replicas


def average(lst):
    return sum(lst) / len(lst)

def dUnion(d1, d2):
    all_keys = set(d1.keys()).union(set(d2.keys()))
    out = dict()
    for k in all_keys:
        if k in d1:
            out[k] = d1[k]
        else:
            out[k] = d2[k]
    return out

def findStrictMotifMatches(motif, dag):
    downgraph_nodes = map(lambda k: (k, nx.algorithms.descendants(dag, k)), dag.nodes_iter())
    downgraphs = map(lambda n: (n[0], nx.DiGraph(dUnion({n[0]:dag[n[0]]},
                                                        {x:dag[x] for x in n[1]}))),
                     downgraph_nodes)
    return set(map(lambda p: p[0],
                   filter(lambda x: nx.is_isomorphic(motif, x[1]),
                          downgraphs)))

def createHist(lst):
    return list(map(lambda x: lst.count(x), range(max(lst)+1)))

def createDAGHist(dag):
    return createHist(list(map(len, dag.adjacency_list())))

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))

def findAllCombosOfNodesUnder(node, dag, size):
    out_node_lists = [[node]]
    count = 0
    while any(map(lambda x: len(x) != size, out_node_lists)):
        node_list = out_node_lists.pop(0)
        print(node_list)
        for child_combo in powerset(dag[node_list[-1]]):
            if len(node_list) < size:
                out_node_lists.append(node_list+list(child_combo))
            elif len(node_list) == size:
                out_node_lists.append(node_list)
        count += 1
        if count > 5: break
    return out_node_lists

#+END_SRC

**** Partitioning Utils

#+BEGIN_SRC python :session :results output silent

def plotPartitions(G, partition, outfile):
    plt.figure()
    size = float(len(set(partition.values())))
    pos = nx.spring_layout(G)
    count = 0.
    for com in set(partition.values()) :
        list_nodes = [nodes for nodes in partition.keys()
                                    if partition[nodes] == com]
        nx.draw_networkx_nodes(G, pos, list_nodes, node_size = 20,
                                    node_color = str(count / size))
        count = count + 1.
    nx.draw_networkx_edges(G, pos, alpha=0.5)
    plt.savefig(outfile)

def plotPartitionComparison(graphs, partitions, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    modularities = list(map(lambda G_part: community.modularity(G_part[1], G_part[0]),
                            zip(graphs, partitions)))
    axs.plot(range(len(modularities)), modularities, 'r+')
    axs.set_title('Modularity v Replica Count')
    axs.set_xlabel('Replica Count')
    axs.set_ylabel('Modularity')
    fig.tight_layout()
    plt.savefig(outfile)

def theoremNameToPartitionOutfile(theorem_name):
    return './Images/'+theorem_name+'_partitions.png'

def plotPartitionsFromTheoremName(theorem_name):
    outfile = theoremNameToPartitionOutfile(theorem_name)
    if not os.path.exists(outfile):
        orig, replicas = importReplicas(theorem_name)
        testDAG(orig)
        G = nx.Graph(orig)
        partition = community.best_partition(G)
        plotPartitions(nx.Graph(orig), partition, outfile)

def theoremNameToModularitiesOutfile(theorem_name):
    return './Images/'+theorem_name+'_modularities.png'

def plotModularitiesFromTheoremName(theorem_name):
    outfile = theoremNameToModularitiesOutfile(theorem_name)
    if not os.path.exists(outfile):
        orig, replicas = importReplicas(theorem_name)
        graphs = list(map(nx.Graph, [orig] + replicas))
        testDAG(graphs[0])
        partitions = list(map(community.best_partition, graphs))
        plotPartitionComparison(graphs, partitions, outfile)

#+END_SRC

**** ev_8
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
plotPartitionsFromTheoremName(theorem_name)
theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_partitions.png]]

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
plotModularitiesFromTheoremName(theorem_name)
theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_modularities.png]]

**** ev_8_alt
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8_alt'
plotPartitionsFromTheoremName(theorem_name)
theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_alt_partitions.png]]

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8_alt'
plotModularitiesFromTheoremName(theorem_name)
theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/ev_8_alt_modularities.png]]


#+END_SRC

**** sqrt2_not_rational
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
plotPartitionsFromTheoremName(theorem_name)
theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_partitions.png]]

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
plotModularitiesFromTheoremName(theorem_name)
theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:./Images/sqrt2_not_rational_modularities.png]]


#+END_SRC

**** sqrt2_not_rational_d3__
***** Partition

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational_d3'
#plotPartitionsFromTheoremName(theorem_name)
#theoremNameToPartitionOutfile(theorem_name)
#+END_SRC

#+RESULTS:

***** Partition Replicas

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational_d3'
#plotModularitiesFromTheoremName(theorem_name)
#theoremNameToModularitiesOutfile(theorem_name)
#+END_SRC

#+RESULTS:


#+END_SRC

    *

**** extra

#+BEGIN_SRC python :session :results output silent
theorem_name = 'ev_8'
orig, replicas = importReplicas(theorem_name)
testDAG(orig)

ave = average(list(map(nx.algorithms.dag_longest_path_length,
                    replicas)))
#print(ave)
#print(nx.algorithms.dag_longest_path_length(orig))

#a_to_bcd = {'a':{'b','c','d'},'b':set(),'c':set(),'d':set()}
#assert(findStrictMotifMatches(nx.DiGraph(a_to_bcd),
#                       orig) == {'App3'})

#a_to_bc = {'a':{'b','c'},'b':set(),'c':set()}
#assert(findStrictMotifMatches(nx.DiGraph(a_to_bc),
#                       orig) == set())
#print(list(map(lambda x: findStrictMotifMatches(nx.DiGraph(a_to_bc),
#                       x), replicas)))
#app1 = dUnion({'d':{'e','f','a'}, 'e':set(),'f':set()}, a_to_bcd)
#print(app1)
#print(findStrictMotifMatches(nx.DiGraph(app1), orig))

#+END_SRC


*** DAG Motif Finding

#+BEGIN_SRC python :session :results output silent

def countFeedForward(dag):
    count = 0
    for n in dag:
        children = dag[n]
        for ch in children:
            grandchildren = dag[ch]
            if any(children & grandchildren):
                #print(n)
                count += 1
    return count

assert(countFeedForward(ev_8_dag) == 2)

def getAllFeedForwardMatches(dag):
    matches = []
    for n in dag:
        children = dag[n]
        for child in children:
            grandchildren = dag[child]
            for grandchild in grandchildren:
                if grandchild in children:
                    matches.append({n,child,grandchild})
    return matches

assert(getAllFeedForwardMatches(ev_8_dag)
       == [{'App1', 'App3', 'ev_SS'}, {'App2', 'App1', 'ev_SS'}])

def hasCrossRefs(group_of_matches, dag):
    has_cross_refs = False
    for i in range(len(group_of_matches)):
        match, rest = group_of_matches[i], group_of_matches[:i] + group_of_matches[i+1:]
        match_children = set()
        for x in match:
            match_children = match_children | dag[x]
        rest_nodes = set()
        for y in rest:
            rest_nodes = rest_nodes | y
        if any(match_children & rest_nodes):
            return True
    return has_cross_refs

assert(hasCrossRefs([{'App2','App1','ev_SS'},{'App3'}], ev_8_dag))
assert(not hasCrossRefs([{'App2','App1','ev_SS'},{'2'}], ev_8_dag))

def getLargestNonIntersectingGroup(matches, dag):
    largest_size = 0
    largest_group_of_matches = None
    for group_of_matches in powerset(matches):
        if group_of_matches:
            if len(group_of_matches) <= 1:
                is_overlapping = False
            else:
                is_overlapping = any(group_of_matches[0].intersection(*group_of_matches[1:]))
            if (not is_overlapping and not hasCrossRefs(group_of_matches, dag)
                                   and len(group_of_matches) > largest_size):
                largest_group_of_matches = group_of_matches
                largest_size = len(group_of_matches)
    return list(largest_group_of_matches) if largest_group_of_matches else []


assert(
    getLargestNonIntersectingGroup(
        [{'App1', 'App3', 'ev_SS'}, {'App2', 'App1', 'ev_SS'}], ev_8_dag) ==
    [{'App3', 'App1', 'ev_SS'}])

def removeGroupOfMatches(group_of_matches, dag):
    previous_motif_nodes = list(filter(lambda x: x[:6] == 'motif_', dag))
    if previous_motif_nodes:
        max_previous_motif_num = max(map(lambda y: int(y[6:]), previous_motif_nodes))
    else:
        max_previous_motif_num = 0
    new_motif_name = 'motif_' + str(max_previous_motif_num)
    new_dag = dag.copy()
    for match in group_of_matches:
        new_motif_name = new_motif_name[:6] + str(int(new_motif_name[6:])+1)
        new_dag[new_motif_name] = set()
        for node in dag:
            if any(dag[node] & match):
                new_dag[node] = (dag[node] - match) | {new_motif_name}
            if node in match:
                new_dag[new_motif_name] = new_dag[new_motif_name] | (dag[node] - match)
                del new_dag[node]
    return new_dag

def removeMatch(match, dag):
    previous_motif_nodes = list(filter(lambda x: x[:6] == 'motif_', dag))
    if previous_motif_nodes:
        max_previous_motif_num = max(map(lambda y: int(y[6:]), previous_motif_nodes))
    else:
        max_previous_motif_num = 0
    new_motif_name = 'motif_' + str(max_previous_motif_num)
    new_dag = dag.copy()
    new_motif_name = new_motif_name[:6] + str(int(new_motif_name[6:])+1)
    new_dag[new_motif_name] = set()
    for node in dag:
        if any(dag[node] & match):
            new_dag[node] = (dag[node] - match) | {new_motif_name}
        if node in match:
            new_dag[new_motif_name] = new_dag[new_motif_name] | (dag[node] - match)
            del new_dag[node]
    return new_dag

assert(
    removeGroupOfMatches([{'App3', 'App1', 'ev_SS'}], ev_8_dag) ==
    {'6': set(), '4': set(), 'App2': {'6', 'motif_1'}, '2': set(),
     'ev_8.ev_2': set(), 'motif_1': {'ev_8.ev_2', '2', '4'}})

def compressDAG(dag, repeat=1):
    new_dag = dag.copy()
    for _ in range(repeat):
        matches = getAllFeedForwardMatches(new_dag)
        #print("matches", matches)
        if matches:
            match = list(matches)[0]
            new_dag = removeMatch(match, new_dag)
        #group_of_matches = getLargestNonIntersectingGroup(matches, new_dag)
        #print("g of matches", group_of_matches)
        #if group_of_matches:
        #    new_dag = removeGroupOfMatches(group_of_matches, new_dag)
    return new_dag

def getCompressedDAGSizes(dag,repeat=1, theorem_name=None):
    new_dag = dag.copy()
    sizes = [len(new_dag)]
    for i in range(repeat):
        matches = getAllFeedForwardMatches(new_dag)
        if matches:
            match = list(matches)[0]
            new_dag = removeMatch(match, new_dag)
        sizes.append(len(new_dag))
        if theorem_name:
            plotDependencyGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
    return sizes


def getCompressedDAGs(dag, repeat=1):
    new_dag = dag.copy()
    out_dags = [dag.copy()]
    for i in range(repeat):
        matches = getAllFeedForwardMatches(new_dag)
        print('hi',matches)
        if matches:
            match = list(matches)[0]
            new_dag = removeMatch(match, new_dag)
        out_dags.append(new_dag.copy())
    return out_dags

def getNumMotifs(dag, repeat=1, check_dag=True, theorem_name=None):
      new_dag = dag.copy()
      num_motifs = []
      print('0', nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
      for i in range(repeat):
          matches = getAllFeedForwardMatches(new_dag)
          num_motifs.append(len(matches))
          if matches:
              match = list(matches)[0]
              new_dag = removeMatch(match, new_dag)
          if check_dag:
              print(str(i+1), nx.is_directed_acyclic_graph(nx.DiGraph(new_dag)))
          if theorem_name:
              plotDependencyGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
      return num_motifs

#+END_SRC

*** Plot DAG motif finding and removal
**** ev_8

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_dag_compressed.png'
new_dag = compressDAG(ev_8_dag)
plotDependencyGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_dag_compressed.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_mod_dag_compressed.png'
ev_8_dag_mod = ev_8_dag.copy()
ev_8_dag_mod['2'] = {'ev_8.ev_2'}
new_dag = compressDAG(ev_8_dag_mod, repeat=2)
plotDependencyGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_mod_dag_compressed.png]]

**** ev_8_alt

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compressed.png'
new_dag = compressDAG(theoremsToDAG(ev_8_alt_tree))
plotDependencyGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compressed.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compressed_2.png'
new_dag = compressDAG(theoremsToDAG(ev_8_alt_tree),repeat=2)
plotDependencyGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compressed_2.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compressed_3.png'
new_dag = compressDAG(theoremsToDAG(ev_8_alt_tree),repeat=3)
plotDependencyGraph(nx.DiGraph(new_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compressed_3.png]]

*** Plot size v num compressions
**** Utils

#+BEGIN_SRC python :session :results output silent

def plotLineGraph(vals, outfile, figsize=(6,4)):
    fig, axs = plt.subplots(1, 1, sharex = True, figsize=figsize)
    axs.plot(range(len(vals)), vals, 'r+')
    fig.tight_layout()
    plt.savefig(outfile)

def plotLineGraphs(vals, outfile):
    figsize = (6,3*len(vals))
    fig, axs = plt.subplots(len(vals), 1, sharex = True, figsize=figsize)
    for i in range(len(vals)):
        ax = axs[i]
        ax.plot(range(len(vals[i])), vals[i], 'r+')
    fig.tight_layout()
    plt.savefig(outfile)


#+END_SRC

**** ev_8

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_dag_compression_comparison.png'
dag = ev_8_dag
sizes = getCompressedDAGSizes(dag, repeat=3, theorem_name='ev_8')
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_dag_compression_comparison.png]]

**** ev_8_alt

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_dag_compression_comparison.png'
dag = theoremsToDAG(ev_8_alt_tree)
sizes = getCompressedDAGSizes(dag, repeat=15, theorem_name='ev_8_alt')
print(sizes)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_dag_compression_comparison.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/ev_8_alt_gen_dag_compression_comparison.png'
orig, replicas = importReplicasToDict('ev_8_alt')
sizes = [getCompressedDAGSizes(replica, repeat=20, theorem_name='ev_8_alt')
           for replica in [orig]+replicas[:3]]
print(sizes)
plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_alt_gen_dag_compression_comparison.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
outfile = 'Images/sqrt2_not_rational_compression_comparison.png'
dag = sqrt2_dag
sizes = getCompressedDAGSizes(dag, repeat=300)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_compression_comparison.png]]

Too slow to run this -- unsure why

#+BEGIN_SRC python :session :results file
outfile = 'Images/sqrt2_not_rational_gen_compression_comparison.png'
#orig, replicas = importReplicasToDict('sqrt2_not_rational')
#sizes = [getCompressedDAGSizes(dag, repeat=10, theorem_name='sqrt2_not_rational')
#         for dag in [orig]+replicas[:1]]
#plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_gen_compression_comparison.png]]



#+BEGIN_SRC python :session :results file
outfile = 'Images/sqrt2_not_rational_num_motifs.png'
dag = sqrt2_dag
sizes = getNumMotifs(dag, repeat=300)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_num_motifs.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/sqrt2_not_rational_gen_num_motifs.png'
orig, replicas = importReplicasToDict('sqrt2_not_rational')
sizes = getNumMotifs(random.sample(replicas,1)[0], check_dag=False, repeat=300)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_gen_num_motifs.png]]


birthday shorter than random

#+BEGIN_SRC python :session :results file
outfile = 'Images/birthday_paradox_compression_comparison.png'
#orig, replicas = importReplicasToDict('birthday_paradox')
#sizes = getNumMotifs(orig, check_dag=False, repeat=800)
#plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_compression_comparison.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/birthday_paradox_gen_compression_comparison.png'
#orig, replicas = importReplicasToDict('birthday_paradox')
#sizes = getNumMotifs(random.sample(replicas,1)[0], check_dag=False, repeat=1500)
#plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_gen_compression_comparison.png]]

*** Understand cycle creation in factorial
**** factorial

Notice that there are no cycles here despite the recursion

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_dag.png'
fact_string = "(Top (Definition Top.fact (Fix (Functions (App fact 0 (Prod n nat nat) (Lambda n nat (Case 0 (Lambda n nat nat) (CaseMatch n) (CaseBranches (App S O) (Lambda n' nat (App Coq.Init.Nat.mul n (App fact n')))))))) 0)))"
fact_tree = parenStringToLists(fact_string)
fact_dag = theoremsToDAG(fact_tree)
print(fact_dag)
plotDependencyGraph(nx.DiGraph(fact_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_dag.png]]

I don't believe I can create a cycle on the first pass, but unsure.
Try compression until cycle creation.

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_repeat_motif.png'
dags = getCompressedDAGs(fact_dag, repeat=2)
plotDependencyGraphList([nx.DiGraph(x) for x in dags], outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_repeat_motif.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_num_motifs.png'
sizes = getNumMotifs(fact_dag, repeat=4)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_num_motifs.png]]

Much higher average stopping point.

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(fact_dag), repeat=8)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_gen_num_motifs.png]]



#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_dag.png'
forward_string = "(Top (Definition Top.forward (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (Cast (Cast (App eq_refl (Axiom Top.C) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b))) REVERTcast (App eq (Axiom Top.C) (App f (App pair (Axiom Top.A) (Axiom Top.B) (App Coq.Init.Datatypes.fst (Axiom Top.A) (Axiom Top.B) (App pair (Axiom Top.A) (Axiom Top.B) a b)) (App Coq.Init.Datatypes.snd (Axiom Top.A) (Axiom Top.B) (App pair (Axiom Top.A) (Axiom Top.B) a b)))) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))) REVERTcast (App eq (Axiom Top.C) (App Top.uncurry (App Top.curry f) (App pair (Axiom Top.A) (Axiom Top.B) a b)) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))))"
forward_tree = parenStringToLists(forward_string)
forward_dag = theoremsToDAG(forward_tree)
plotDependencyGraph(nx.DiGraph(forward_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_num_motifs.png'
sizes = getNumMotifs(forward_dag, repeat=15)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_num_motifs.png]]


Similar average stopping point for random

#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(forward_dag), repeat=15)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_gen_num_motifs.png]]



#+BEGIN_SRC python :session :results file
outfile = 'Images/forward_repeat_motif.png'
dags = getCompressedDAGs(forward_dag, repeat=3)
plotDependencyGraphList([nx.DiGraph(x) for x in dags], outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/forward_repeat_motif.png]]


#+BEGIN_SRC python :session :results file
outfile = 'Images/app_dag.png'
app_string = "(Top (Definition Top.app (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (App Top.uncurry (App Top.curry f) (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))"
app_tree = parenStringToLists(app_string)
app_dag = theoremsToDAG(app_tree)
plotDependencyGraph(nx.DiGraph(app_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/app_dag.png]]


#+BEGIN_SRC python :session :results file
outfile = 'Images/app_num_motifs.png'
sizes = getNumMotifs(app_dag, repeat=15)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/app_num_motifs.png]]






#+BEGIN_SRC python :session :results file
outfile = 'Images/curry_dag.png'
curry_string = "(Top (Definition Top.curry (Lambda f (Prod Anonymous (App prod (Axiom Top.A) (Axiom Top.B)) (Axiom Top.C)) (Lambda a (Axiom Top.A) (Lambda b (Axiom Top.B) (App f (App pair (Axiom Top.A) (Axiom Top.B) a b)))))))"
curry_tree = parenStringToLists(curry_string)
curry_dag = theoremsToDAG(curry_tree)
plotDependencyGraph(nx.DiGraph(curry_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/curry_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/curry_num_motifs.png'
sizes = getNumMotifs(curry_dag, repeat=5)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/curry_num_motifs.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/curry_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(curry_dag), repeat=5)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/curry_gen_num_motifs.png]]


#+BEGIN_SRC python :session :results file
outfile = 'Images/uncurry_dag.png'
uncurry_string = "(Top (Definition Top.uncurry (Lambda g (Prod Anonymous (Axiom Top.A) (Prod Anonymous (Axiom Top.B) (Axiom Top.C))) (Lambda p (App prod (Axiom Top.A) (Axiom Top.B)) (App g (App Coq.Init.Datatypes.fst (Axiom Top.A) (Axiom Top.B) p) (App Coq.Init.Datatypes.snd (Axiom Top.A) (Axiom Top.B) p))))))"
uncurry_tree = parenStringToLists(uncurry_string)
uncurry_dag = theoremsToDAG(uncurry_tree)
plotDependencyGraph(nx.DiGraph(uncurry_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/uncurry_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/uncurry_num_motifs.png'
sizes = getNumMotifs(uncurry_dag, repeat=2)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/uncurry_num_motifs.png]]

Much higher average stopping value.

#+BEGIN_SRC python :session :results file
outfile = 'Images/uncurry_gen_num_motifs.png'
sizes = getNumMotifs(genComparableGraph(uncurry_dag), repeat=10)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/uncurry_gen_num_motifs.png]]

Plan for meeting - try inc dec


*** Test hypo that more cycles in theorem version

There are more in the theorem case, but hard to say if that is just because of the size.

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_dag.png'
dec_inc_string = "(Top (Definition Top.dec_inc (Lambda n nat (App Top.dec (App S n)))))"
dec_inc_tree = parenStringToLists(dec_inc_string)
dec_inc_dag = theoremsToDAG(dec_inc_tree)
print(dec_inc_dag)
plotDependencyGraph(nx.DiGraph(dec_inc_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_num_motifs.png'
sizes = getNumMotifs(dec_inc_dag, repeat=10, theorem_name='dec_inc')
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_num_motifs.png]]


#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_prop_dag.png'
dec_inc_prop_string = "(Top (Definition Top.same' (Lambda n nat (Cast (App Coq.Init.Datatypes.nat_ind (Lambda n nat (App eq nat (App Top.dec (App S n)) n)) (Cast (App eq_refl nat O) REVERTcast (App eq nat (App Top.dec (App S O)) O)) (Lambda n nat (Lambda IHn (App eq nat (App Top.dec (App S n)) n) (Cast (App eq_refl nat (App S n)) REVERTcast (App eq nat (App Top.dec (App S (App S n))) (App S n))))) n) REVERTcast (App eq nat (App Top.dec_inc n) n)))))"
dec_inc_prop_tree = parenStringToLists(dec_inc_prop_string)
dec_inc_prop_dag = theoremsToDAG(dec_inc_prop_tree)
print(dec_inc_prop_dag)
plotDependencyGraph(nx.DiGraph(dec_inc_prop_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_prop_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_prop_num_motifs.png'
sizes = getNumMotifs(dec_inc_prop_dag, repeat=12)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_prop_num_motifs.png]]


#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_dag.png'
eq_string = "(Top (Definition Top.basic_eq' (Lambda n nat (App Coq.Init.Datatypes.nat_ind (Lambda n nat (App eq nat n n)) (App eq_refl nat O) (Lambda n nat (Lambda IHn (App eq nat n n) (App eq_refl nat (App S n)))) n))))"
eq_tree = parenStringToLists(eq_string)
eq_dag = theoremsToDAG(eq_tree)
print([x for x in eq_deb_dag if 'n' in eq_deb_dag[x]])
plotDependencyGraph(nx.DiGraph(eq_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_dag.png]]

#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_num_motifs.png'
sizes = getNumMotifs(eq_dag, repeat=12)
plotLineGraph(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_num_motifs.png]]

DeBruijin is not quite what we are looking for -- is replacing the names inside of the body,
 but we want global names that can be pointed to
This global unique thing is different from alpha renaming
Also a sort of preemptive alpha renaming and only of closed terms

Keep a dictionary during parse, which is passed around with replacement names

#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_deb_dag.png'
eq_deb_string = "(Top (Definition Top.basic_eq' (Lambda n nat (App Coq.Init.Datatypes.nat_ind (Lambda n nat (App eq nat (Rel 1) (Rel 1))) (App eq_refl nat O) (Lambda n nat (Lambda IHn (App eq nat (Rel 1) (Rel 1)) (App eq_refl nat (App S (Rel 2))))) (Rel 1)))))"
eq_deb_tree = parenStringToLists(eq_deb_string)
eq_deb_dag = theoremsToDAG(eq_tree)
print([x for x in eq_deb_dag if 'n' in eq_deb_dag[x]])
plotDependencyGraph(nx.DiGraph(eq_deb_dag), outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_deb_dag.png]]




*** Check num direct loops

#+BEGIN_SRC python :session :results output silent

def countCycles(dag):
    count = 0
    for n in dag:
        children = dag[n]
        for ch in children:
            grandchildren = dag[ch]
            if n in grandchildren:
                #print(n)
                count += 1
    return count

def getAllCycles(dag):
    matches = []
    for n in dag:
        children = dag[n]
        for child in children:
            grandchildren = dag[child]
            if n in grandchildren:
                matches.append({n,child})
    return matches


def getNumCycles(dag, repeat=1, check_dag=True, theorem_name=None):
      new_dag = dag.copy()
      num_motifs = []
      num_cycles = []
      print('0', nx.is_directed_acyclic_graph(nx.DiGraph(dag)))
      for i in range(repeat):
          matches = getAllFeedForwardMatches(new_dag)
          num_motifs.append(len(matches))
          num_cycles.append(countCycles(new_dag)/2)
          if matches:
              match = list(matches)[0]
              new_dag = removeMatch(match, new_dag)
          if check_dag:
              print(str(i+1), nx.is_directed_acyclic_graph(nx.DiGraph(new_dag)))
          if theorem_name:
              plotDependencyGraph(nx.DiGraph(new_dag),
                                './Images/'+theorem_name+'_dag_compressed_'+str(i+1),
                                label=True)
      return num_motifs, num_cycles

#+END_SRC

#+BEGIN_SRC python :session :results file
outfile = 'Images/dec_inc_num_cycles.png'
num_motifs, num_cycles = getNumCycles(dec_inc_dag, repeat=10)
plotLineGraphs([num_motifs, num_cycles], outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/dec_inc_num_cycles.png]]


#+BEGIN_SRC python :session :results file
outfile = 'Images/sqrt2_not_rational_num_cycles.png'
theorem_name = 'sqrt2_not_rational'
sqrt2_dag = theoremsToDAG(sqrt2_tree, 'sqrt2_not_rational')
#gen_sqrt2_dag = genComparableGraph(sqrt2_dag) #P52 in values but not in keys
#plotDependencyGraphs(nx.DiGraph(sqrt2_dag),
#                     nx.DiGraph(gen_sqrt2_dag), outfile, label=False, figsize=(8,8))
dag = sqrt2_dag
motifs_and_cycles = getNumCycles(dag, check_dag = False, repeat=300)
plotLineGraphs(motifs_and_cycles, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_num_cycles.png]]
[[file:Images/sqrt2_not_rational_gen_num_cycles.png]]

Use factorial as worked example.

#+BEGIN_SRC python :session :results file
outfile = 'Images/factorial_num_cycles.png'
sizes = getNumCycles(fact_dag, repeat=4)
plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/factorial_num_cycles.png]]

Work through eq example.

#+BEGIN_SRC python :session :results file
outfile = 'Images/eq_num_cycles.png'
sizes = getNumCycles(eq_dag, theorem_name='eq', repeat=15)
plotLineGraphs(sizes, outfile)
outfile
#+END_SRC

#+RESULTS:
[[file:Images/eq_num_cycles.png]]
