* Scott Viteri

** Thing 1

#+BEGIN_SRC emacs-lisp
  (defun org-xor (a b)
    "Exclusive or."
    (if a (not b) b))
 #+END_SRC

+ 1 2 3

\begin{equation}
a^2+b^2=c^2
\end{equation}

If $a^2=b$ and \( b=2 \), then the solution must be either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].

#+BEGIN_SRC scheme
(define (even? n)
    (= (remainder n 2) 0))
#+END_SRC

#+RESULTS
: #<unspecified>

Hello my name is blank

#+BEGIN_SRC haskell
factorial 0 = 1
factorial n = n * (factorial (n - 1))
#+END_SRC

** Thing 2


#+BEGIN_SRC scheme :exports none
(load-extension "libfive-guile" "scm_init_libfive_modules")
(use-modules (libfive kernel) (libfive vec) (libfive csg) (libfive shapes) (libfive transforms))

(define (expt-irrat b n)
  (exp (* n (log b))))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (lp-norm p)
  (lambda-shape (x y z)
    (let ((p-pow (lambda (x) (expt-irrat x p))))
    (- (expt-irrat (apply + (map (compose p-pow abs) (list x y z)))
                   (/ 1 p))
       1))))

(shape->mesh (scale-xyz (lp-norm 1.2) #[5 5 5]) "test.stl" 10 '((-5 . 5) (-5 . 5) (-5 . 5)))

#+END_SRC

#+RESULTS:

#+name: inline-js
#+begin_src js :exports none
console.log('Test');
#+end_src

#+RESULTS: inline-js
: Test
: undefined

#+begin_src elisp :noweb yes :exports results :results html
(concat
     "<script src='three.js'></script>\n"
     "<script src='stats.js'>""</script>\n"
     "<script src='detector.js'></script>\n"
     "<script src='viewer.js'></script>\n"
     "<script type=\"text/javascript\">\n"
     "<<inline-js>>\n"
     "</script>\n"
)
#+end_src

#+RESULTS:
#+BEGIN_EXPORT html
<script src='three.js'></script>
<script src='stats.js'></script>
<script src='detector.js'></script>
<script src='viewer.js'></script>
<script type="text/javascript">
console.log('Test');
</script>
#+END_EXPORT

#+BEGIN_SRC scheme :exports none
(define bounds '((-5 . 5) (-5 . 5) (-5 . 5)))

(define (view shape)
  (set-shape shape bounds 10))

(define (rot shape count)
  (if (> count 0)
      (begin (usleep 50000)
             (set-shape shape bounds 10)
             (rot (rotate-z shape 0.1) (- count 1)))
      )
  )

(make-viewer)

(define (anim-morph shape1 shape2 total-steps)
  (let ((step-size (/ 1 total-steps)))
    (define (helper num-steps)
      (if (> num-steps 0)
          (begin (usleep 5000)
                 (set-shape (morph shape1 shape2 (- 1  (* step-size num-steps)))
                            bounds
                            10)
                 (helper (- num-steps 1)))))

    (helper total-steps))
)

(define split (symmetric-x (move (sphere 2) #[3 0 0])))
(anim-morph (sphere 2) split 100)

#+END_SRC

#+ATTR_HTML: :controls controls :width 350
#+BEGIN_VIDEO
#+HTML: <source src="split.mp4" type="video/mp4">
#+END_VIDEO
