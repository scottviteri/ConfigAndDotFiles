open classical
local attribute [instance] prop_decidable

/- The "local attribute" lets you use the by_cases
   and by_contradiction tactics. -/

example (p : Prop) : p ∨ ¬ p :=
begin
  by_cases p,
  { left, assumption },
  right, assumption
end

example (p : Prop) : p ∨ ¬ p :=
begin
  by_cases h' : p,
  { left, exact h' },
  right, exact h'
end

/-
Give a calculational proof of the theorem log_mul below. You can use the
rewrite tactic `rw` (and `calc` if you want), but not `simp`.

These objects are actually defined in mathlib, but for now, we'll
just declare them.
-/

constant real : Type
@[instance] constant  orreal : ordered_ring real
constants (log exp : real → real)
constant  log_exp_eq : ∀ x, log (exp x) = x
constant  exp_log_eq : ∀ {x}, x > 0 → exp (log x) = x
constant  exp_pos    : ∀ x, exp x > 0
constant  exp_add    : ∀ x y, exp (x + y) = exp x * exp y

example (x y z : real) :
  exp (x + y + z) = exp x * exp y * exp z :=
by rw [exp_add, exp_add]

example (y : real) (h : y > 0)  : exp (log y) = y :=
exp_log_eq h

theorem log_mul {x y : real} (hx : x > 0) (hy : y > 0) :
  log (x * y) = log x + log y :=
calc
  log (x * y) = log (exp (log x) * exp (log y)) : by rw [exp_log_eq hx, exp_log_eq hy]
  ...         = log (exp (log x + log y))       : by rw (exp_add (log x) (log y))
  ...         = log x + log y                   : by rw (log_exp_eq (log x + log y))


/-
These are all theorems you proved on the second and third assignments.
Do them again, using tactics.
-/

section

variables {p q r : Prop}

example : (p → q) → (¬q → ¬p) :=
begin
  intros hpq hnq,
  by_cases p,
  { have hq : q := hpq h, contradiction },
  { assumption }
end

example : (p → (q → r)) → (p ∧ q → r) :=
begin
  intros hpqr hpq,
  cases hpq with hp hq,
  exact (hpqr hp hq)
end

example : p ∧ ¬q → ¬(p → q) :=
begin
  intros hpnq hpq,
  cases hpnq with hp hnq,
  exact (hnq (hpq hp))
end

example : (¬p ∨ q) → (p → q) :=
begin
  intros hnpq hp,
  by_cases q,
  { assumption },
  { cases hnpq; contradiction }
end

example : (p ∨ q → r) → (p → r) ∧ (q → r) :=
begin
  intros hpqr,
  by_cases (p ∨ q),
  { have hr : r := hpqr h,
    exact (and.intro (λk,hr) (λk,hr))},
  { split,
    {assume hp : p, exact (absurd (or.inl hp) h)},
    {assume hq : q, exact (absurd (or.inr hq) h)}}
end

example : (p → q) → (¬p ∨ q) :=
begin
  intros hpq,
  by_cases p,
  {exact (or.inr (hpq h))},
  {exact (or.inl h)}
end

end

section

variables {α β : Type} (p q : α → Prop) (r : α → β → Prop)

example : (∀ x, p x) ∧ (∀ x, q x) → ∀ x, p x ∧ q x :=
begin
  intros h a,
  cases h with hpx hqx,
  exact (and.intro (hpx a) (hqx a))
end

example : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x :=
begin
  intros hpq x,
  cases hpq,
  {exact (or.inl (hpq x))},
  {exact (or.inr (hpq x))}
end


example : (∃ x, ∀ y, r x y) → ∀ y, ∃ x, r x y :=
begin
  intros hrxy y,
  cases hrxy with a hray,
  exact (⟨a, hray y⟩)
end

theorem e1 : (¬ ∃ x, p x) → ∀ x, ¬ p x :=
begin
  intros hnpx a hpa,
  have h : ∃ (x : α), p x := ⟨a, hpa⟩,
  exact hnpx h
end


example : (¬ ∀ x, ¬ p x) → ∃ x, p x :=
begin
  intros hpx,
  by_contradiction hne,
  have h : (¬ ∃ x, p x) → ∀ x, ¬ p x := e1 p,
  have h2 : ∀ (x : α), ¬ p x := (h hne),
  exact (hpx h2)
end

end

/- The rest of this assignment is only required of graduate students! -/

/- Give tactic proofs of the following. -/
section

variables (man : Type) (barber : man)
variable  (shaves : man → man → Prop)

example (h : ∀ x : man, shaves barber x ↔ ¬ shaves x x) : false :=
begin
  have hiff : shaves barber barber ↔ ¬ shaves barber barber := h barber,
  cases hiff with hforw hback,
  have hbarb : shaves barber barber ∨ ¬ shaves barber barber := em (shaves barber barber),
  cases hbarb with hsb hnsb,
  { exact ((hforw hsb) hsb)},
  { exact (hnsb (hback hnsb))}
end

end

section


variables {α : Type} (p : α → Prop) (r : Prop) (a : α)

example : (r → ∃ x, p x) → ∃ x, (r → p x) :=
begin
  assume hrpx,
  by_cases r,
  { have hpx : ∃ x, p x := hrpx h,
    cases hpx with b hpb,
    exact ⟨b, (λ hr, hpb)⟩},
  {
    have b : α := a,


  }
end

end

/-
Prove the theorem below, using only the ring properties of ℤ enumerated
in Section 4.2 and the theorem sub_self. You should probably work out
a pen-and-paper proof first.
-/

#check sub_self

example (x : ℤ) : x * 0 = 0 :=
sorry
