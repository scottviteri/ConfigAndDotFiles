(* Require Export IndProp. *)

Inductive ev : nat -> Prop :=
| ev_0 : ev 0
| ev_SS : forall n : nat, ev n -> ev (S (S n)).

(*
Print ev.
Check ev_SS.
*)

Theorem ev_4 : ev 4.
Proof. apply ev_SS. Show Proof. apply ev_SS. apply ev_0. Qed.
(* Print ev_4. *)

Theorem ev_8 : ev 8.
Proof. apply  (ev_SS 6 (ev_SS 4 (ev_SS 2 (ev_SS 0 (ev_0))))). Qed.


(* PrintAST ev_4. *)
(* PrintAST ev_8. *)
(* Set PrintAST Indexing. *)
(* PrintAST ev_4 with depth 3. *)


Ltac find_if :=
  match goal with
   | [ |- if ?X then _ else _ ] => destruct X
  end.

Theorem hmm : forall (a b c : bool),
  if a
    then if b
      then True
      else True
    else if c
      then True
      else True.
  intros; repeat find_if; constructor.
Qed.


Inductive or (A B : Prop) : Prop :=
  | or_introl : A -> A \/ B
  | or_intror : B -> A \/ B
where "A \/ B" := (or A B) : type_scope.

Inductive False : Prop := .
Inductive True : Prop := I : True.
Inductive bool : Set :=
  | true : bool
  | false : bool.

Theorem left_or : (forall A B : Prop, A -> A \/ B).
Proof.
  intros A B. intros H. apply or_introl. apply H.
Qed.
(* Print left_or. *)

Theorem left_or' : (forall A B : Prop, A -> A \/ B).
Proof.
  apply (fun (A B : Prop) (H : A) => or_introl A B H).
Qed.
(* Print left_or'. *)

Theorem forward_huge : (forall A B C : Prop, A -> (A->B) -> (A->B->C) -> C).
Proof.
  intros A B C.
  intros proof_of_A A_implies_B A_imp_B_imp_C.
  pose (proof_of_B := A_implies_B proof_of_A).
  pose (proof_of_C := A_imp_B_imp_C proof_of_A proof_of_B).
  exact proof_of_C.
Qed.

(* Print forward_huge. *)

(* Notice backward_huge does not grow with increasing depth *)
(* this is because there are depth affects unfolding of inductive defn's, and there are none here *)

Theorem backward_huge : (forall A B C : Prop, A -> (A->B) -> (A->B->C) -> C).
Proof.
  intros A B C.
  intros proof_of_A A_implies_B A_imp_B_imp_C.
  refine (A_imp_B_imp_C _ _).
    exact proof_of_A.
    refine (A_implies_B _).
      exact proof_of_A.
Qed.

(* Print backward_huge. *)

(*
Print plus. 
Print Nat.
*)

