section -- work through lecture

variables x y z : ℕ
#check @nat.rec_on

theorem add_assoc' : (x + y) + z = x + (y + z) :=
  nat.rec_on z
    rfl
    (λ n ih,
      calc
        x + y + nat.succ n = nat.succ ((x + y) + n) : rfl
        ...                = nat.succ (x + (y + n)) : by rw ih
        ...                = x + (y + nat.succ n)     : rfl)

theorem zero_add' : 0 + x = x :=
nat.rec_on x
  rfl
  (λ n (ih : 0 + n = n), calc
    0 + nat.succ n = nat.succ (0 + n) : rfl
    ...            = nat.succ n       : by rw ih)


#check nat.add_succ

theorem succ_add' : nat.succ x + y = nat.succ (x + y) :=
nat.rec_on y
  rfl
  (λ n ih, calc
    nat.succ x + nat.succ n = nat.succ (nat.succ x + n) : rfl
    ...                     = nat.succ (nat.succ (x + n)) : by rw ih)


theorem succ_add'' : nat.succ x + y = nat.succ (x + y) :=
begin
  induction y with n ih,
  { refl },
  { rw [nat.add_succ, ih]}
end

end


/- For these problems, you can use `rw`, but not `simp`. -/

/- Remember that addition and multiplication are defined by recursion on the
   second argument. Also, `1` is definitionally the same as `nat.succ 0`.
-/

section

variables m n : ℕ

example : n + 0 = n := rfl

example : n + nat.succ m = nat.succ (n + m) := rfl

example : n * 0 = 0 := rfl

example : n * (nat.succ m) = n * m + n := rfl

example : 1 = nat.succ 0 := rfl

/- these theorems also have names: -/

#check nat.add_zero
#check nat.add_succ
#check nat.mul_zero
#check nat.mul_succ

end

/-
In lecture, we proved the following:
-/

#check @nat.zero_add
#check @nat.succ_add
#check @nat.add_assoc
#check @nat.add_comm

/-
Using these, prove the following, using (proof terms). You can use
the `rw` tactic (and `calc`) for proofs.

(In fact, you can use the more general theorems `add_comm`, `add_assoc`,
without the `nat` prefix.)
-/

namespace hidden

-- this means that you do not have to use the `nat.` prefix
export nat (succ)

#check succ

variables (m n k : ℕ)

#check nat.mul_succ m n

theorem mul_add : m * (n + k) = m * n + m * k :=
nat.rec_on k
  rfl
  (λ x ih, calc
    m * (n + succ x) = m * (succ (n + x))   : rfl
    ...              = m * (n + x) + m      : by rw nat.mul_succ
    ...              = m * n + m * x + m    : by rw ih
    ...              = m * n + (m * x + m)  : by rw nat.add_assoc
    ...              = m * n + (m * succ x) : by rw nat.mul_succ)

#check nat.add_assoc

theorem mul_add' : m * (n + k) = m * n + m * k :=
begin
  induction k with x ih,
  { refl },
  { rw [nat.mul_succ, ih],
    rw nat.add_assoc,
    rw nat.mul_succ }
end

theorem mul_add'' : m * (n + k) = m * n + m * k :=
begin
  induction k with x ih,
  { refl },
  { simp [nat.mul_succ, ih, (nat.mul_succ m x)] }
end

theorem zero_mul : 0 * n = 0 :=
nat.rec_on n
  rfl
  (λ x ih, calc
    0 * succ x = 0 * x + 0 : by rw nat.mul_succ
    ...        = 0 * x     : rfl
    ...        = 0         : by rw ih)

theorem zero_mul' : 0 * n = 0 :=
begin
  induction n with x ih,
  { refl },
  { rw [nat.mul_succ, ih] }
end

theorem zero_mul'' : 0 * n = 0 :=
begin
  induction n with x ih,
  {refl},
  { simp [nat.mul_succ, ih] }
end

#check nat.mul_succ
#check nat.add_succ
#check nat.add_assoc

theorem succ_mul : succ m * n = m * n + n :=
nat.rec_on n
 rfl
 (λ x ih, calc
   succ m * succ x = succ m * x + succ m    : by rw (nat.mul_succ (succ m) x)
   ...             = m * x + x + succ m     : by rw ih
   ...             = succ (m * x + x + m)   : by rw nat.add_succ
   ...             = succ (m * x + (x + m)) : by rw nat.add_assoc
   ...             = succ (m * x + (m + x)) : by rw (nat.add_comm x m)
   ...             = succ (m * x + m + x)   : by rw ←nat.add_assoc
   ...             = succ (m * succ x + x)  : by rw nat.mul_succ
   ...             = m * succ x + succ x    : by rw nat.add_succ)

theorem succ_mul' : succ m * n = m * n + n :=
begin
  induction n with x ih,
  { refl },
  { rw [(nat.mul_succ (succ m) x), ih, nat.add_succ],
    rw [nat.add_assoc, (nat.add_comm x m)],
    rw [←nat.add_assoc, nat.mul_succ] }
end

theorem succ_mul'' : succ m * n = m * n + n :=
begin
  induction n with x ih,
  { refl },
  { simp [nat.mul_succ, ih, nat.add_succ] }
end


#check nat.mul_succ
#check nat.succ_mul
#check mul_add

theorem mul_assoc : (m * n) * k = m * (n * k) :=
nat.rec_on k
 rfl
 (λ x ih, calc
  (m * n) * succ x = (m * n) * x + m * n : by rw nat.mul_succ
  ...              = m * (n * x) + m * n : by rw ih
  ...              = m * (n * x + n)     : by rw ←mul_add
  ...              = m * (n * succ x)    : by rw nat.mul_succ)

theorem mul_assoc' : (m * n) * k = m * (n * k) :=
begin
  induction k with x ih,
  { refl },
  { rw [nat.mul_succ, ih, ←mul_add, nat.mul_succ] }
end

theorem mul_assoc'' : (m * n) * k = m * (n * k) :=
begin
  induction k with x ih,
  { refl },
  { simp [nat.mul_succ, ih, mul_add, nat.mul_succ] }
end


theorem mul_comm : m * n = n * m :=
nat.rec_on n
 (calc m * 0 = 0     : rfl
       ...   = 0 * m : by rw zero_mul)
 (λ x ih, calc
   m * (succ x) = m * x + m    : by rw nat.mul_succ
   ...          = x * m + m    : by rw ih
   ...          = (succ x) * m : by rw ←nat.succ_mul)

theorem mul_comm' : m * n = n * m :=
begin
  induction n with x ih,
  { rw [zero_mul, mul_zero] },
  { rw [nat.mul_succ, ih, ←nat.succ_mul] }
end

theorem mul_comm'' : m * n = n * m :=
begin
  induction n with x ih,
  { simp [zero_mul, mul_zero] },
  { simp [nat.mul_succ, ih, nat.succ_mul] }
end


end hidden

/-
Now, do them again, using the induction tactic.
-/

namespace hidden'

export nat (succ)

variables (m n k : ℕ)

theorem mul_add : m * (n + k) = m * n + m * k :=
begin
  induction k with x ih,
  { refl },
  { rw [nat.mul_succ, ih],
    rw nat.add_assoc,
    rw nat.mul_succ }
end


theorem zero_mul : 0 * n = 0 :=
begin
  induction n with x ih,
  { refl },
  { rw [nat.mul_succ, ih] }
end

theorem succ_mul : succ m * n = m * n + n :=
begin
  induction n with x ih,
  { refl },
  { rw [(nat.mul_succ (succ m) x), ih, nat.add_succ],
    rw [nat.add_assoc, (nat.add_comm x m)],
    rw [←nat.add_assoc, nat.mul_succ] }
end

theorem mul_assoc : (m * n) * k = m * (n * k) :=
begin
  induction k with x ih,
  { refl },
  { rw [nat.mul_succ, ih, ←mul_add, nat.mul_succ] }
end

theorem mul_comm : m * n = n * m :=
begin
  induction n with x ih,
  { rw [zero_mul, mul_zero] },
  { rw [nat.mul_succ, ih, ←nat.succ_mul] }
end

end hidden'

/-
Remember that lists are defined inductively with a `nil` and `cons` operation.
You can write `nil` as `[]` and `cons a l` as `a :: l`. The `1ength` function
is defined recursively. The append function, `append s t`, written `s ++ t`,
is also defined recursively.
-/

section
open list

variable {α : Type*}
variables s t : list α
variable a : α

-- we have to give the type of `nil` here, because Lean can't infer it.
-- we could also write `(nil : list α)`.

theorem length_nil : length (@nil α) = 0 := rfl

#check nil_append
#check cons_append
#check length_cons

#eval [1, 2, 3] ++ [4, 5]
#eval length [1, 2, 3, 4, 5]

end

/-
Prove the following.
-/

section

open list

variable {α : Type*}
variables s t : list α
variable a : α

#check nat.zero_add

example : length (s ++ t) = length s + length t :=
list.rec_on s
  (calc
    length (nil ++ t) = length t              : by rw nil_append
    ...               = 0 + length t          : by rw nat.zero_add
    ...               = length nil + length t : by refl)
  (λ hx tx ih, calc
    length ((hx :: tx) ++ t) = length (hx :: (tx ++ t))   : by refl
    ...                      = length (tx ++ t) + 1       : by rw length_cons
    ...                      = length tx + length t + 1   : by rw ih
    ...                      = length tx + (length t + 1) : by rw nat.add_assoc
    ...                      = length tx + (1 + length t) : by rw (nat.add_comm (length t) 1)
    ...                      = length tx + 1 + length t   : by rw nat.add_assoc
    ...                      = length (hx :: tx) + length t : by rw length_cons )


example : length (s ++ t) = length s + length t :=
begin
  induction s with hx tx ih,
  { rw [nil_append], simp },
  { simp [length_cons, ih, nat.add_assoc, nat.add_comm] }
end


end

/-
Define an inductive data type consisting of terms built up from the
following constructors:

  `const n`, a constant denoting the natural number n
  `var n`, a variable, numbered n
  `plus s t`, denoting the sum of s and t
  `times s t`, denoting the product of s and t
-/

inductive nat_term
| const : ℕ → nat_term
| var : ℕ → nat_term
| plus : nat_term → nat_term → nat_term
| times : nat_term → nat_term → nat_term
-- ....

open nat_term

/-
Recursively define a function that evaluates any such term with respect to
an assignment `val : ℕ → ℕ` of values to the variables.

For example, if `val 4 = 3
-/

def eval (val : ℕ → ℕ) : nat_term → ℕ
| (const n) := n
| (var n) :=  val n
| (plus t1 t2) := eval t1 + eval t2
| (times t1 t2) := eval t1 * eval t2

#check eval

/-
Test it out by using #eval on some terms. You can use the following `val` function. In that case, for example, we would expect to have

  eval val (plus (const 2) (var 1)) = 5
-/

def val : ℕ → ℕ
| 0 := 4
| 1 := 3
| 2 := 8
| _ := 0


#eval (eval val (plus (const 2) (var 1)))


example : eval val (plus (const 2) (var 1)) = 5 := rfl

#eval eval val (plus (const 2) (var 1))


/-
Only graduate students are required to do the next one. This assignment is long
and this is tricky, so don't worry if you don't finish it.

Below, we define a function `rev` that reverses a list. It uses an auxiliary function
`append1`.

If you can, prove that the length of the list is preserved, and that
`rev (rev l) = l` for every `l`. The theorem below is given as an example, and should
be helpful.

Note that when you use the equation compiler to define a function foo, `rw [foo]` uses
one of the defining equations if it can. For example, `rw [append1, ...]` in the theorem
uses the second equation in the definition of `append1`
-/

section

open list
variable {α : Type*}

def append1 (a : α) : list α → list α
| nil      := [a]
| (b :: l) := b :: (append1 l)

def rev : list α → list α
| nil := nil
| (a :: l) := append1 a (rev l)

theorem length_append1 (a : α) (l : list α): length (append1 a l) = length l + 1 :=
begin
  induction l with b l ih,
  { reflexivity },
  rw [append1, length_cons, length_cons, ih]
end

theorem length_rev (l : list α) : length (rev l) = length l :=
list.rec_on l
  rfl
  (λ h t ih, calc
    length (rev (h :: t)) = length (append1 h (rev t)) : by rw rev
    ...                   = length (rev t) + 1         : by rw length_append1
    ...                   = length t + 1               : by rw ih
    ...                   = length (h :: t)            : by refl)

theorem length_rev' (l : list α) : length (rev l) = length l :=
begin
  induction l with h t ih,
  {refl},
  { rw [rev, length_append1, ih], refl }
end

-- modify this theorem -- just do behavior of append1
theorem append1_append (h : α) (t : list α) : append1 h t = t ++ [h] :=
list.rec_on t
  rfl
  (λ hd tl ih, calc
    append1 h (hd :: tl) = hd :: (append1 h tl)  : by rw append1
    ...                  = hd :: (tl ++ [h])     : by rw ih
    ...                  = (hd :: tl) ++ [h]     : by rw list.cons_append)

#check list.cons_append

-- theorem rev_cons (h : α) (t : list α) : (h :: rev t) = rev (t ++ [h]) :=
-- begin
--   induction t with hd tl ih,
--   {refl},
--   { rw rev, rw append1_append, rw ←list.cons_append, rw ih,  }
-- end

#check rev

-- theorem rev_cons (h : α) (t : list α) : (h :: rev t) = rev (t ++ [h]) :=
-- list.rec_on t
--   rfl
--   (λ hd tl ih, calc
--     h :: rev (hd :: tl) = h :: append1 hd (rev tl)   : by rw rev
--     ...                 = h :: ((rev tl) ++ [hd])    : by rw append1_append
--     ...                 = (h :: rev tl) ++ [hd]      : by rw ←list.cons_append
--     ...                 = rev (tl ++ [h]) ++ [hd]    : by rw ih
--     ...                 = rev (append1 h tl) ++ [hd]      : by rw append1_append
--     ...                 = append1 hd (rev (append1 h tl)) : by rw (append1_append hd (rev (append1 h tl)))
--     ...                 =
-- )

#check @list.append

-- theorem rev_append (l1 : list α) (l2 : list α) : rev (l1 ++ l2) = rev l2 ++ rev l1 :=
-- list.rec_on l1
--   rfl
--   (λ h t ih, calc
--     rev (h :: t ++ l2) = rev (h :: (t ++ l2)) : by rw list.append
--     ...                = append1 h (rev (t ++ l2)) : by rw append1
--     ...                = append1 h (rev l2 ++ rev t) : by rw ih
--
--   )



-- theorem part_rev_rev (h : α) (t : list α) : h :: (rev (rev t)) = rev (rev (h :: t)) :=
-- list.rec_on t
--   rfl
--   (λ h' t' ih, calc
--     h :: rev (rev (h' :: t')) = h :: rev (append1 h' (rev t')) : by rw rev
--     ...                       = h :: rev (rev t' ++ [h'])      : by rw append1_append
--     ...                       =
--
-- )


theorem rev_rev (l : list α) : rev (rev l) = l :=
list.rec_on l
  rfl
  (λ h t ih, calc
    rev (rev (h :: t)) = rev (append1 h (rev t))  : by rw rev
    ...                = rev ((rev t) ++ [h])     : by rw (append1_append h (rev t))
    ...                = h :: (rev (rev t))       : by rw ←rev_cons
    ...                =
)

-- theorem rev_rev' (l : list α) : rev (rev l) = l :=
-- begin
--   induction l with h t ih,
--   { refl },
--   {  }
-- end


end
