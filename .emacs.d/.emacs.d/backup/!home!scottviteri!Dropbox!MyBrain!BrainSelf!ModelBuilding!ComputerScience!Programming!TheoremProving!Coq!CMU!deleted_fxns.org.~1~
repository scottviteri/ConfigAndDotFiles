#+BEGIN_SRC python :session :results output

def memoize(f):
    memo = {}
    def helper(x):
        immutable_x = pickle.dumps(x)
        if immutable_x not in memo:
            memo[immutable_x] = f(x)
        return memo[immutable_x]
    return helper

def isFlat(l):
    return not any(filter(lambda x: isinstance(x,list), l))

def add1(l):
    """ Adds 1 to each element in a nested numerical array
    Example: add1([[1,2,3],4,5])
    # base: [1,2,3] -> [2,3,4]
    # ind_step: [[2,3,4],4,5] -> [[2,3,4],5,6]
    """
    if isFlat(l): # base case
        return list(map(lambda x:x+1, l))
    else: # inductive step
        return list(map(lambda x: add1(x) if isinstance(x,list) else x+1, l))

assert(add1([1,2,3]) == [2,3,4])
assert(add1([[1,2,3],4,5]) == [[2,3,4],5,6])

def nestedMap(f,l):
    """ Map f over a nested list """
    if isFlat(l):
       return list(map(f,l))
    else:
       return list(map(lambda x: nestedMap(f,x) if isinstance(x,list) else f(x), l))

assert(nestedMap(lambda x:x+1, [[1,2,3],4,5]) == [[2,3,4],5,6])

def add1ToEndOfTuple(l):
   """ Adds 1 to the first tuple element in a nested tuple array """
   # [[(0,1),(0,2),(0,3)],(0,4),(0,5)] -> [[(1,1),(1,2),(1,3)],(1,4),(1,5)]
   return nestedMap(lambda x: (*x[:-1], x[-1]+1), l)

assert(add1ToEndOfTuple([[(1,0),(2,0),(3,0)],(4,0),(5,0)]) == [[(1,1),(2,1),(3,1)],(4,1),(5,1)])

def nestedMapListFxn(f,l):
   if isFlat(l): return f(l)
   else: return f([f(x) if isinstance(x,list) else x for x in l])

print(nestedMapListFxn(lambda l:l[::-1], [[1,2],3,[4,5]]))

#+END_SRC

#+RESULTS:
: [[5, 4], 3, [2, 1]]

labelDepth cannot be written in terms of nestedMap or nestedMapListFxn
 b/c it has different behavior at the flat list and nested list levels

#+BEGIN_SRC python :session :results output

def labelDepth(l): # takes non-empty list of lists, where 1st element is not a list
    """ Labels each element of nested list with tree depth
    # labelDepth(['e','e','e']) -> [('e',0),('e',1),('e',1)]
    # labelDepth(['e',['e','e','e'],'e']) -> [('e',0),[('e',1),('e',2),('e',2)],('e',2)]
    """
    h, t = l[0], l[1:] # b/c non-empty
    if isFlat(l): # base case
        # ['e','e','e'] -> [('e',0),('e',1),('e',1)]
        return [(h,0)] + [(x,1) for x in t]
    else: # inductive step
        # [ 'e'   ,[('e',0),('e',1),('e',1)], 'e'   ] ->
        # [('e',0),[('e',1),('e',2),('e',2)],('e',1)]
        return [(h,0)] +  [add1ToEndOfTuple(labelDepth(x)) \
                         if isinstance(x, list) else (x,1) for x in t]

assert(labelDepth(['e','e','e']) == [('e',0),('e',1),('e',1)])
assert(labelDepth(['e',['e','e','e'],'e']) == [('e',0),[('e',1),('e',2),('e',2)],('e',1)])

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

def indicatorFxn(prop, x): return 1 if prop(x) else 0

def countProperty(prop, l):
    # (lambda x:x==5) -> [5,[2,5],5] -> 3
    if isFlat(l): return len(list(filter(prop,l)))
    else:
        return sum([countProperty(prop,x) if isinstance(x,list)
                else indicatorFxn(prop,x) for x in l])

assert(countProperty(lambda x:x==5, [5,2,5]) == 2)
assert(countProperty(lambda x:x==5, [5,[2,5],5]) == 3)

def accumulate(start,l,f):
   total = start
   for x in l:
      total = f(total,x)
      yield total

def isEmpty(l): return not l

def label(prop, l, prev_count=-1, withTuples=False): # [2,1,1] -> [2,(1,0),(1,1)]
   if isEmpty(l): # base case : [] -> []
       return l
   else: # ind_step : (2 :: [1,1]) -> (2 :: [(1,0),(1,1)])
       h,t=l[0],l[1:]
       if prop(h):
          transformed_head = [(*h, prev_count+1)] if withTuples else [(h, prev_count+1)]
          prev_count += 1
       else:
          transformed_head = [h]
       return transformed_head + label(prop, t, prev_count, withTuples=withTuples)

assert(label(lambda x:x==1, []) == [])
assert(label(lambda x:x==1, [2,1,1]) == [2,(1,0),(1,1)])

def augWithCountProperty(prop,l,prev_count=-1,withTuples=False):
    # (lambda x:x==1) -> [1,[2,1,1],1] -> [(1,0),[2,(1,1),(1,2)],(1,3)]
    if isFlat(l): # base case
       # [2,1,1] -> [2,(1,0),(1,1)]
       return label(prop, l, prev_count, withTuples)
    else: #ind_step
       # [1,[2,(1,0),(1,1)],1] -> [(1,0),[2,(1,1),(1,2)],(1,3)]
       outlst = []
       for x in l:
           if isinstance(x,list):
               outlst.append(augWithCountProperty(prop,x,prev_count,withTuples))
               prev_count += countProperty(prop, x)
           else:
               if prop(x):
                   outlst.append((*x,prev_count+1) if withTuples else (x,prev_count+1))
                   prev_count += 1
               else:
                   outlst.append(x)
       return outlst

assert(augWithCountProperty(lambda x:x==1, [2,1,1]) == [2,(1,0),(1,1)])

assert(augWithCountProperty(lambda x:x==1, [ 1   ,[2, 1   , 1   ], 1   ])
                                   == [(1,0),[2,(1,1),(1,2)],(1,3)])

assert(augWithCountProperty(lambda x:x[0]==1,
                            [(1,0),[(2,0),(1,0),(1,0)],(1,0)],
                            withTuples=True)
      == [(1,0,0),[(2,0),(1,0,1),(1,0,2)],(1,0,3)])

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

def nestedMax(l):
   return nestedMapListFxn(lambda x: max(x), l)

def nestedMaxDepth(l):
   # [('e',0),[('e',1),('e',2),('e',2)],('e',2)] -> 2
   if isFlat(l):
       return max(l, key=lambda el: el[1])
   else:
       return max([nestedMaxDepth(x) if isinstance(x,list) else x for x in l], key=lambda el: el[1])

def getDepth(l): return l[1]
def getBFSCount(l): return l[2]

def nestedMaxBFSCountWithDepth(l, depth):
   return getBFSCount(
         nestedMapListFxn(lambda x: max(filter(lambda y: getDepth(y)==depth, x),
                          key=lambda el: getBFSCount(el)), l))

assert(nestedMax([3,[1,4],2]) == 4)
assert(getDepth(nestedMaxDepth([('e',0),[('e',1),('e',2),('e',2)],('e',1)])) == 2)
assert(nestedMaxBFSCountWithDepth([('e',0),[('e',1,0),('e',2),('e',2)],('e',1,1)],1) == 1)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

#cannot do by recursion on list level,
# since counts have dependencies outside of their local list
def numberBFS(l, start_id=0): # takes non-empty lists of tuple list, where 1st element is tuple
    """ Labels each element of a nested list with BFS ordering
    numberBFS(['e','e','e']) == [('e',0),('e',1),('e',2)]
    numberBFS(['e',['e','e','e'],'e']) == [('e',0),[('e',1),('e',3),('e',4)],('e',2)]
    """
    aug_lst = labelDepth(copy.deepcopy(l))
    prev_count = -1
    for depth in range(getDepth(nestedMaxDepth(aug_lst))+1):
        aug_lst = augWithCountProperty(prop=(lambda x: getDepth(x) == depth),
                                       l=aug_lst,
                                       prev_count=prev_count,
                                       withTuples=True)
        prev_count += countProperty(lambda x: depth==getDepth(x), aug_lst)

    return nestedMap(lambda x:(x[0],x[2]+start_id), aug_lst)

#def numberDictBFS(l, start_id=0):
#    # numberBFS({'a':{'b':{},'c':{}}, 'd':{}}) = {('a',0):0}


assert(numberBFS(['e','e','e']) == [('e',0),('e',1),('e',2)])
assert(numberBFS(['e',['e','e','e'],'e']) == [('e',0),[('e',1),('e',3),('e',4)],('e',2)])

#aug_l1 = numberBFS(l1)
#print(aug_l1)
#print(numberBFS(l1, 3))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :session :results output

def tupleTreeFromAugTree(l):
    """ Takes BFS labeled nested list, outputs (parent, kind, id) form """
    # [('e',0),[('e',1),('e',2)]] -> [(None,'e',0), (0,'e',1), (1,'e',2)]
    #print(l)
    if isFlat(l): #[('e',1),('e',2)] -> [(None,'e',1),(1,'e',2)]
        h,t=l[0],l[1:]
        return [(None,*h)] + [(h[1],*x) for x in t]
    else: # [('e',0),[(None,'e',1),(1,'e',2)]] -> [(None,'e',0),(0,'e',1), (1,'e',2)]
        outlst = [(None,*l[0])]
        parent_id = l[0][1]
        for x in l[1:]:
            if isinstance(x,list):
                tuples = tupleTreeFromAugTree(x)
                h,t=tuples[0],tuples[1:]
                outlst.append((parent_id,*h[1:]))
                outlst.extend(t)
            else:
                outlst.append((parent_id, *x))
        return outlst

def tupleTreeFromList(lst, start_id=0):
    return set(tupleTreeFromAugTree(numberBFS(lst, start_id)))

def stringToTupleTree(s):
    return tupleTreeFromList(stringToLists(s))

assert(tupleTreeFromAugTree([('e',1),('e',2)]) == [(None,'e',1),(1,'e',2)])
assert(tupleTreeFromAugTree([('e',0),[('e',1),('e',2)]]) == [(None,'e',0), (0,'e',1), (1,'e',2)])

#tt = set(tupleTreeFromAugTree(aug_l1))
#print(tt)
#print()

#print(l1)
#print(tupleTreeFromList(l1,3))

#+END_SRC
