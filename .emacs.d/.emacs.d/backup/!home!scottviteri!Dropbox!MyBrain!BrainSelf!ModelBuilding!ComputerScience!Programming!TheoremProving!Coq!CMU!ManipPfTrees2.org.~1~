#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

Goal is to create a compression of proof trees by finding motifs and pulling them out as separate trees.

First, grab some sample proof trees.

#+BEGIN_SRC python :session
even_4_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2))'
even_8_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2)) (Definition Top.ev_8 (App ev_SS (App S (App S (App S (App S (App S (App S O)))))) (App ev_SS (App S (App S (App S (App S O)))) Top.ev_4)))'
#+END_SRC

#+RESULTS:

We will need to parse these into a form that python can more directly read.

I am using a list of lists, where [A,B,[C,D]] represents
 A
 |\
 B C
   |
   D

#+BEGIN_SRC python :session :results output

import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json

def push(obj, l, depth):
    while depth:
        l = l[-1]
        depth -= 1
    l.append(obj)


def stringToLists(s):
    s = s[1:-1]
    groups = []
    depth = 0
    try:
        word = ''
        for char in s:
            if char == '(':
                push([], groups, depth)
                depth += 1
            elif char == ')':
                if word:
                    push(word, groups, depth)
                    word = ''
                depth -= 1
            elif char == ' ':
                if word:
                    push(word, groups, depth)
                    word = ''
            else:
                word += char
    except IndexError:
        raise Exception('Parentheses mismatch')
    if depth > 0:
        raise Exception('Parentheses mismatch')
    else:
        return groups


def focusToNewLetters(focus_string):
    if focus_string[1] == '(': return '['
    elif focus_string[1] == ')': return ']'
    elif focus_string[1] == ' ': return ','
    if focus_string[1].isalnum() \
        and (focus_string[0] == '(' or focus_string[0] == ' ') \
        and (focus_string[2] == ')' or focus_string[2] == ' '):
        return '\"'+focus_string[1]+'\"'
    if focus_string[1].isalnum() and (focus_string[0] == '(' or focus_string[0] == ' '):
        return '\"'+focus_string[1]
    if focus_string[1].isalnum() and (focus_string[2] == ')' or focus_string[2] == ' '):
        return focus_string[1]+'\"'
    return focus_string[1]


def parenStringToLists(string, is_filename=False):
    accum = ''
    focus = "   "
    if is_filename:
        with open(string, 'r') as f:
            paren_string = f.read()[:-1]
    else:
        paren_string = string
    rooted_paren_string = '(Top ' + paren_string + ')'
    for char in rooted_paren_string:
        focus = focus[1:] + str(char)
        accum += focusToNewLetters(focus)
    focus = focus[1:] + str(char)
    accum += focusToNewLetters(focus)
    return json.loads(accum[1:])


print(parenStringToLists('(a b (c d e))'))
print()

l1_from_file = parenStringToLists('../100FamousProofs/Proofs/ev_4.txt', True)
print(l1_from_file)

l1 = parenStringToLists(even_4_string)
assert(l1 == l1_from_file)
#+END_SRC

#+RESULTS:
: ['Top', ['a', 'b', ['c', 'd', 'e']]]
:
: ['Top', ['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']], ['Definition', 'Top.ev_4', ['App', 'ev_SS', ['App', 'S', ['App', 'S', 'O']], 'Top.ev_2']]]

#+BEGIN_SRC python :session

def recur(lst, out_file, count=0):
    if count == 0:
        out_file.write('None ' + str(lst[0]) + ' '+ str(count) +'\n')
        #print(None, lst[0], count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
    prev = count
    for unit in lst[1:]:
        count += 1
        if isinstance(unit,list):
            out_file.write(str(prev) + ' ' + str(unit[0]) + ' '+ str(count) +'\n')
            #print(prev, unit[0], count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
        else:
            out_file.write(str(prev) + ' ' + str(unit) + ' '+ str(count) +'\n')
            #print(prev, unit, count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
        if isinstance(unit, list):
            count = recur(unit, out_file, count)
    return count


with open('out.txt','w') as f:
    recur(['A','B',['C','D','E']], f)

with open('out.txt','r') as f:
    out = f.read()
    assert([len(l.split(' ')) == 3 for l in out.split('\n')[:-1]])
    print(out)

#+END_SRC

#+RESULTS:
: 4


Want to convert from nested list format to [(parent, name, id)] format.
It will be convenient to have ids strictly decrease as we go down a tree,
  and one way we can do this is by labeling the nodes in BFS order.

In order to do this, we'll first need to build up some helper functions to deal with nested lists.

#+BEGIN_SRC python :session

def evalTuple(tuple):
    return (eval(tuple[0]),tuple[1],eval(tuple[2]))

def loadTupleTreeFromFile(filename):
    with open(filename, "r") as f:
        tuple_strings = f.readlines()[::-1]
    tuple_tree = set([evalTuple(tuple(s[:-1].split(" "))) for s in tuple_strings])
    return tuple_tree

#def subNats(tree):
#    max_tree_size = 3
#    n_tree = lambda n : {(None,'App',0),(0,'S',1)}.union({(0,'O',2) if n==0 else (0,str(n),2)})
#    succ_subbed = tree
#    for n in range(len(tree)):
#        prev_succ_subbed = copy.copy(succ_subbed)
#        succ_subbed = substituteMotifTree(n_tree(n), succ_subbed, max_tree_size, subst_name=str(n+1), append=False)
#        if (prev_succ_subbed == succ_subbed): #print('subbed: ',n)
#            return succ_subbed
#    return succ_subbed

def genTupleTree(string, is_filename=False):
    lstOfLsts = parenStringToLists(string, is_filename)
    with open('out.txt','w') as f:
        c = recur(lstOfLsts, f)
    return loadTupleTreeFromFile('out.txt')

assert(genTupleTree(even_4_string) == genTupleTree('../100FamousProofs/Proofs/ev_4.txt',True))

even_4_tree = genTupleTree('../100FamousProofs/Proofs/ev_4.txt',True)
even_8_tree = genTupleTree('../100FamousProofs/Proofs/ev_8.txt',True)
sqrt2_tree = genTupleTree('../100FamousProofs/Proofs/sqrt2.txt',True)

#+END_SRC

#+RESULTS:
