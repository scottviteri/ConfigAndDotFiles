#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

** Tree reading / manipulation utilities
*** Top level imports

#+BEGIN_SRC python :session :results output silent

import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json
import functools
import pdb
import cProfile
import subprocess
import networkx as nx
import os

#+END_SRC

#+RESULTS:

*** Read tree files into nested lists

First, grab some sample proof trees.

#+BEGIN_SRC python :session :results output silent
even_4_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2))'
even_8_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2)) (Definition Top.ev_8 (App ev_SS (App S (App S (App S (App S (App S (App S O)))))) (App ev_SS (App S (App S (App S (App S O)))) Top.ev_4)))'
#+END_SRC

#+RESULTS:

We will need to parse these into a form that python can more directly read.

I am using a list of lists, where [A,B,[C,D]] represents
 A
 |\
 B C
   |
   D

**** Trees to nested lists, without natural number substitution

#+BEGIN_SRC python :session :results output silent

def push(obj, l, depth):
    while depth:
        l = l[-1]
        depth -= 1
    l.append(obj)


def stringToLists(s):
    s = s[1:-1]
    groups = []
    depth = 0
    try:
        word = ''
        for char in s:
            if char == '(':
                push([], groups, depth)
                depth += 1
            elif char == ')':
                if word:
                    push(word, groups, depth)
                    word = ''
                depth -= 1
            elif char == ' ':
                if word:
                    push(word, groups, depth)
                    word = ''
            else:
                word += char
    except IndexError:
        raise Exception('Parentheses mismatch')
    if depth > 0:
        raise Exception('Parentheses mismatch')
    else:
        return groups


def focusToNewLetters(focus_string):
    if focus_string[1] == '(': return '['
    elif focus_string[1] == ')': return ']'
    elif focus_string[1] == ' ': return ','
    if focus_string[1].isalnum() \
        and (focus_string[0] == '(' or focus_string[0] == ' ') \
        and (focus_string[2] == ')' or focus_string[2] == ' '):
        return '\"'+focus_string[1]+'\"'
    if focus_string[1] not in '( )' and (focus_string[0] == '(' or focus_string[0] == ' '):
        # (a -> ("a or ' a' -> ' "a'
        return '\"'+focus_string[1]
    if focus_string[1] not in '( )' and (focus_string[2] == ')' or focus_string[2] == ' '):
        # b) -> b") or 'b ' -> 'b" '
        return focus_string[1]+'\"'
    return focus_string[1]

#+END_SRC

**** Tree printing utilities

#+BEGIN_SRC python :session :results output silent

def isFlat(l):
    return not any(filter(lambda x: isinstance(x,list), l))

def concat(lst_of_lsts):
    return functools.reduce(lambda x,y:x+y, lst_of_lsts, [])

def printTreeHelper(tree):
    """ Prints tree by prepending '+---' to each layer
    Example: printTreeHelper(['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']])
    # base: ['App', 'ev_SS', 'O', 'ev_0'] -> ['App', '+---ev_SS', '+---O', '+---ev_0']
    # ind_step: ['Definition', 'Top.ev_2', ['App', '+---ev_SS', '+---O', '+---ev_0']]
    #  -> ['Definition', '+---Top.ev_2', '+---App', '+---+---ev_SS', '+---+---O', '+---+---ev_0']]
    """
    h,t = tree[0], tree[1:]
    if not isinstance(tree, list):
        assert(isinstance(tree, str))
        return [tree]
    if isFlat(tree):
        return [h] + list(map(lambda x: "+---"+x, t))
    return [h] + concat([list(map(lambda x: "+---"+x, printTreeHelper(x))) for x in t])

def printTree(tree, max_depth=None):
    for x in printTreeHelper(tree):
        if max_depth is not None:
            if "+---"*max_depth not in x:
                print(x)
        else:
            print(x)


#+END_SRC

**** Substitute nat notation of App S chains

#+BEGIN_SRC python :session :results output silent

# let search_val be a flat list
def replaceFlatList(lst_of_lsts, search_val, replace_val):
    l = []
    for x in lst_of_lsts:
        if search_val == x:
            l.append(replace_val)
        else:
            if isinstance(x,list):
                if isFlat(x):
                    l.append(x)
                else:
                    l.append(replaceFlatList(x, search_val, replace_val))
            else:
                l.append(x)
    return l

def subNats(lst_of_lsts):
    l = replaceFlatList(lst_of_lsts, ['App','S','O'], '1')
    last_l = None
    n = 1
    while last_l != l:
       last_l = l
       l = replaceFlatList(l, ['App','S',str(n)], str(n+1))
       n += 1
    return l

def parenStringToLists(paren_string, debug=False):
    accum = ''
    paren_string = paren_string.strip()
    #print(paren_string.count('('), paren_string.count(')'))
    assert(paren_string.count('(') == paren_string.count(')'))
    focus = "  " + paren_string[0]
    for char in paren_string[1:]:
        focus = focus[1:] + str(char)
        accum += focusToNewLetters(focus)
        #print(focus[1], focusToNewLetters(focus))
    accum += ']'
    if debug:
    	with open('paren_lists_debug.txt','w') as f:
            f.write(accum)
    return subNats(json.loads(accum))

def theoremNameToLists(theorem_name, depth=2, debug=False):
    theorem_folder = './ProofTrees/Individual/'+theorem_name
    if not os.path.exists(theorem_folder):
        subprocess.call(["./coq_proof_to_trees.sh", theorem_name])
    with open(theorem_folder + '/d'+str(depth)+'.txt', 'r') as f:
        paren_string = f.read()
    assert(paren_string != '')
    return parenStringToLists('(Top ' + paren_string.strip() + ')', debug=debug)

assert(parenStringToLists('(a b (c d e))') == ['a','b',['c','d','e']])

even_4_tree = theoremNameToLists('ev_4')
even_8_tree = theoremNameToLists('ev_8')
sqrt2_tree = theoremNameToLists('sqrt2_not_rational')

print(even_8_tree)

#+END_SRC

#+RESULTS:

*** Substitute definitions back into the original tree branch -- tree modulo theorems

#+BEGIN_SRC python :session :results output silent

def replaceVal(lst_of_lsts, search_val, replace_val):
    """ similar to subRec, but search target is a single value """
    l = []
    for x in lst_of_lsts:
        if instance(x,list):
            l.append(replaceVal(x, search_val, replace_val))
        else:
            if search_val == x:
                l.append(replace_val)
            else:
                l.append(x)
    return l

def replaceVals(lst_of_lsts, search_replace_dict):
    """ similar to replaceVal, but multiple search targets with different replace_vals """
    l = []
    for x in lst_of_lsts:
        if isinstance(x,list):
            l.append(replaceVals(x, search_replace_dict))
        else:
            if x in search_replace_dict:
                l.append(search_replace_dict[x])
            else:
                l.append(x)
    return l

def accumMatches(lst_of_lsts, test):
    l = []
    for x in lst_of_lsts:
        if isinstance(x, list):
            l.extend(accumMatches(x, test))
        else:
            if test(x):
                l.append(x)
    return l

def inNestedList(elem, lst_of_lsts):
    for x in lst_of_lsts:
        if isinstance(x,list):
            if inNestedList(elem, x):
                return True
        else:
            if elem == x:
                return True
    return False

# note that PrintAST can append same definition many times!

def replaceDefinitions(lst_of_lsts, max_depth=math.inf, debug=False):
    """ Substitute unrolled definitions back into main top level definition """
    orig_tree, dep_trees = lst_of_lsts[-1], lst_of_lsts[1:-1]
    replace_string_candidates = set(map(lambda x:x[1], dep_trees))
    replace_strings = list(filter(lambda x: inNestedList(x, orig_tree[2]), replace_string_candidates))
    replace_string_candidates = replace_string_candidates - set(replace_strings)
    #print(replace_strings)
    def_to_subtree = {x[1]:x for x in lst_of_lsts}
    depth = 0
    l = []
    search_replace_dict = {}
    while replace_string_candidates and depth < max_depth:
        search_replace_dict = {k:def_to_subtree[k] for k in def_to_subtree if k in replace_strings}
        #print('orig', orig_tree)
        orig_tree = replaceVals(orig_tree, search_replace_dict)
        depth += 1
        replace_strings = list(filter(lambda x: inNestedList(x, orig_tree[2]), replace_string_candidates))
        #replace_strings = concat([accumMatches(subtree[2], lambda x: x[:4] == "Top.")
        #                          for subtree in search_replace_dict.values()])
        replace_string_candidates = replace_string_candidates - set(replace_strings)
    search_replace_dict = {k:def_to_subtree[k] for k in def_to_subtree if k in replace_strings}
    orig_tree = replaceVals(orig_tree, search_replace_dict)
    if debug:
        with open('replace_def_debug.txt','w') as f:
            f.write(str(orig_tree))
    return orig_tree


#printTree(even_4_tree,4)
#printTree(replaceDefinitions(even_4_tree),4)

assert(replaceDefinitions(even_8_tree,2) == replaceDefinitions(even_8_tree))

#+END_SRC

#+RESULTS:


** Analyze features of proof trees

*** Proof tree plotting utilities

 #+BEGIN_SRC python :session :results output silent

 def sumLsts(lsts):
     max_len = max(map(len, lsts))
     def zeroFill(lst): return lst + [0]*(max_len - len(lst))
     return list(map(sum, zip(*map(zeroFill,lsts))))

 def countNodesAtDepths(tree):
     """ Counts num nodes at each depth
     Example: countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']])
     # base: ['c','d','e'] -> [1,2], 'b' -> [1]
     # ind_step: ['a', [1], [1,2], [1,2]] -> [1,3,4]
     """
     if not isinstance(tree, list): return [1]
     h,t = tree[0], tree[1:]
     if isFlat(tree): return [1,len(t)]
     return [1] + sumLsts(list(map(countNodesAtDepths, t)))

 def countNodes(tree):
     if not isinstance(tree, list): return 1
     if isFlat(tree): return len(tree)
     return 1 + sum([countNodes(branch) for branch in tree[1:]])

 def strip(s):
     return s.split('/')[-1]

 def modStrip(s):
     l = s.split('/')
     return l[-2] + '_' + l[-1]

 assert(countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']]) == [1,3,4])


 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC python :session :results output silent

 def plotNodesVTreeDepth(theorem_name, max_depth, solid=False, debug=False):
   f = 'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
   if not os.path.isfile(f):
       fig, ax = plt.subplots(figsize=(6,6))
       for d in range(1,max_depth+1):
           if d == 1:
               ax = plt.subplot(max_depth,1,d)
           else:
               ax = plt.subplot(max_depth,1,d, sharex = ax)
           ax.set_title(theorem_name + ' depth '+str(d))
           tree = theoremNameToLists(theorem_name, depth=d, debug=debug)
           if solid:
               ax.plot(countNodesAtDepths(tree)[1:], label='No substitution')
               ax.plot(countNodesAtDepths(replaceDefinitions(tree)), label='Defn substitution')
           else:
               ax.plot(countNodesAtDepths(tree)[1:], '_', label='No substitution')
               ax.plot(countNodesAtDepths(replaceDefinitions(tree)), '|', label='Defn substitution')
           fig.tight_layout()
           ax.legend()
           if d != max_depth:
               plt.setp(ax.get_xticklabels(), visible=False)
       plt.savefig(f)

 def depthToNumNodes(depth, theorem_name):
    tree = theoremNameToLists(theorem_name, depth=depth)
    substitutionTree = replaceDefinitions(tree)
    return (countNodes(tree), countNodes(substitutionTree))

 def proj1(tuple_list): return list(map(lambda x:x[0], tuple_list))

 def proj2(tuple_list): return list(map(lambda x:x[1], tuple_list))

 def plotNodesVExtractionDepth(theorem_name, max_depth, figsize = (6,6)):
    f = 'Images/'+theorem_name+'_extraction_depth.png'
    if not os.path.isfile(f):
        fig, axs = plt.subplots(2, 2, sharex = True, figsize=figsize)
        depth_list = list(range(1,max_depth+1))
        log_depth_list = list(map(lambda x: math.log(x), depth_list))
        num_nodes = list(map(lambda depth: depthToNumNodes(depth, theorem_name), depth_list))
        tree_num_nodes, sub_tree_num_nodes = proj1(num_nodes), proj2(num_nodes)
        axs[0][0].plot(depth_list, tree_num_nodes)
        axs[0][1].plot(depth_list, sub_tree_num_nodes)
        axs[0][0].set_title('No Sub Tree')
        axs[0][1].set_title('Sub Tree')
        axs[0][0].set_xlabel('Extraction Depth')
        axs[0][1].set_xlabel('Extraction Depth')
        axs[0][0].set_ylabel('Num Nodes in Tree')
        axs[1][0].set_ylabel('Log Num Nodes in Tree')
        axs[1][0].plot(log_depth_list, list(map(lambda x: math.log(x), tree_num_nodes)))
        axs[1][1].plot(log_depth_list, list(map(lambda x: math.log(x), sub_tree_num_nodes)))
        axs[1][0].set_xlabel('Log Extraction Depth')
        axs[1][1].set_xlabel('Log Extraction Depth')
        fig.tight_layout()
        plt.savefig(f)


  #+END_SRC

 #+RESULTS:

*** Plot num nodes at particular tree depths
**** ev_4

  #+BEGIN_SRC python :session :results file
      theorem_name = 'ev_4'
      plotNodesVTreeDepth(theorem_name,max_depth=3,solid=False)
      'Images/'+theorem_name+'_tree_depth.png'
  #+END_SRC

  #+RESULTS:
  [[file:Images/ev_4_tree_depth.png]]

**** ev_8

  #+BEGIN_SRC python :session :results file
      theorem_name = 'ev_8'
      max_depth = 3
      plotNodesVTreeDepth(theorem_name,max_depth=max_depth)
      'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
  #+END_SRC

  #+RESULTS:
  [[file:Images/ev_8_tree_depth_3.png]]

**** sqrt2_not_rational

  #+BEGIN_SRC python :session :results file
      theorem_name = 'sqrt2_not_rational'
      max_depth = 5
      plotNodesVTreeDepth(theorem_name,max_depth=max_depth)
      'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
  #+END_SRC

  #+RESULTS:
  [[file:Images/sqrt2_not_rational_tree_depth_5.png]]

**** birthday_paradox

  #+BEGIN_SRC python :session :results file
      theorem_name = 'birthday_paradox'
      max_depth = 5
      plotNodesVTreeDepth(theorem_name, max_depth=max_depth)
      'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
  #+END_SRC

  #+RESULTS:
  [[file:Images/birthday_paradox_tree_depth_5.png]]

**** bertrand_ballot

  #+BEGIN_SRC python :session :results file
      theorem_name = 'bertrand_ballot'
      max_depth = 3
      plotNodesVTreeDepth(theorem_name, max_depth=max_depth)
      'Images/'+theorem_name+'_tree_depth_'+str(max_depth)+'.png'
  #+END_SRC

  #+RESULTS:
  [[file:Images/bertrand_ballot_tree_depth_3.png]]

*** Plot num nodes of the tree at particular extraction depths
**** ev_8

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    plotNodesVExtractionDepth(theorem_name,max_depth=3)
    'Images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_extraction_depth.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2_not_rational'
    plotNodesVExtractionDepth(theorem_name,max_depth=5)
    'Images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_extraction_depth.png]]

**** birthday_paradox

#+BEGIN_SRC python :session :results file
    theorem_name = 'birthday_paradox'
    plotNodesVExtractionDepth(theorem_name, max_depth=4)
    'Images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_extraction_depth.png]]

**** bertrand_ballot

#+BEGIN_SRC python :session :results file
    theorem_name = 'bertrand_ballot'
    plotNodesVExtractionDepth(theorem_name, max_depth=3)
    'Images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:Images/bertrand_ballot_extraction_depth.png]]

*** Plot subtree sizes

**** Utilities

#+BEGIN_SRC python :session :results output silent

    def getTreeSize(tree):
        c = 0
        for x in tree:
            if isinstance(x,list):
                c += getTreeSize(x)
            else:
                c += 1
        return c

    def createSubtreeSizePlot(theorem_name, max_depth, num_bins=10, debug=False):
        f = 'Images/'+theorem_name+'_subtree_sizes.png'
        if not os.path.isfile(f):
            fig, axs = plt.subplots(max_depth, 1, sharex = True, figsize=(6,6))
            for depth in range(1,max_depth+1):
                tree = theoremNameToLists(theorem_name, depth=depth)
                if debug:
                    printTree(tree)
                distrib = list(map(getTreeSize, tree[1:]))
                if max_depth > 1:
                    axs[depth-1].hist(distrib, bins=num_bins)
                    axs[depth-1].set_title(theorem_name + ' subtree sizes at depth ' + str(depth))
                else:
                    axs.hist(distrib, bins=num_bins)
                    axs.set_title(theorem_name + ' subtree sizes at depth ' + str(depth))
                #print(distrib)
            plt.savefig(f)

#+END_SRC

**** ev_4

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_4'
    createSubtreeSizePlot(theorem_name, max_depth=3)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_4_subtree_sizes.png]]

The two subtrees just happen to be the same size for ev_4 at extraction depth 2.

**** ev_8

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    createSubtreeSizePlot(theorem_name, max_depth=3)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_subtree_sizes.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2_not_rational'
    createSubtreeSizePlot(theorem_name, max_depth=5, num_bins=40)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_subtree_sizes.png]]

Massive outliers are inherent.

**** birthday_paradox

#+BEGIN_SRC python :session :results file
    theorem_name = 'birthday_paradox'
    createSubtreeSizePlot(theorem_name, max_depth=4, num_bins=40)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_subtree_sizes.png]]

Massive outliers are inherent.

**** bertrand_ballot

#+BEGIN_SRC python :session :results file
    theorem_name = 'bertrand_ballot'
    createSubtreeSizePlot(theorem_name, max_depth=4, num_bins = 50)
    'Images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:Images/bertrand_ballot_subtree_sizes.png]]


** Create Dependency Graph of Theorems

*** Graph plotting utils
**** Dependency graph for a single root theorem

Goal: given a collection of theorems, create the list of theorems that they reference.
 Then use these theorems and lists to generate a directed graph.

How to deal with extraction depth?
 Use only extraction depth 1.
 This way we only generate the graph of "local" dependencies

How to start?
 Use even_4 and even_8. There should be a dependencies from even_8 to even_4.
 Then move on to standard library.

#+BEGIN_SRC python :session :results output silent

def allAtLeaves(elems, tree):
    l = []
    if isinstance(tree, list):
        for x in tree[1:]:
            l.extend(allAtLeaves(elems, x))
    else:
        #tree == leaf
        if tree in elems:
            l.append(tree)
    return l

def theoremToDependencyDict(theorem):
    assert(theorem[0] == 'Top')
    theorem_to_dependencies = {}
    top, theorem_trees = theorem[0], theorem[1:][::-1]
    lemma_candidates = list(map(lambda x: x[1], theorem_trees))
    old_frontier_theorem_indices = [0]
    while old_frontier_theorem_indices:
        new_frontier_theorem_indices = []
        for theorem_i in old_frontier_theorem_indices:
            theorem_name = lemma_candidates[theorem_i]
            dependencies = allAtLeaves(lemma_candidates[max(old_frontier_theorem_indices)+1:],
                                       theorem_trees[theorem_i])
            theorem_to_dependencies[theorem_name] = dependencies
            new_frontier_theorem_indices.extend(
                list(map(lambda x: lemma_candidates.index(x), dependencies)))
        #pdb.set_trace()
        old_frontier_theorem_indices = new_frontier_theorem_indices.copy()
    #print(theorem_to_dependencies)
    return {k:set(v) for k,v in theorem_to_dependencies.items()}

def theoremToDependencyGraph(theorem):
    return nx.DiGraph(theoremToDependencyDict(theorem))

assert(theoremToDependencyDict(
           ['Top', ['Def','b',['c','d']], ['Def','a','b']])
      == {'a':{'b'}, 'b':set()})

assert(theoremToDependencyDict(['Top', ['Def','d','e'], ['Def','c','e'],
                                       ['Def','b',['App','c','d']], ['Def','a','b']])
       == {'a':{'b'},'b':{'c','d'},'c':set(),'d':set()})

#+END_SRC

#+RESULTS:

**** Dependency graph for a list of theorems

#+BEGIN_SRC python :session :results output silent

def mergeDicts(d1,d2):
    merged_dict = {}
    k1, k2 = set(d1.keys()), set(d2.keys())
    for k in k1.union(k2):
        if k in k1 and k in k2:
            merged_dict[k] = d1[k].union(d2[k])
        elif k in k1:
            merged_dict[k] = d1[k]
        elif k in k2:
            merged_dict[k] = d2[k]
    return merged_dict

def theoremListToDependencyDict(theorem_list):
    dep_dicts = list(map(lambda theorem: theoremToDependencyDict(theorem), theorem_list))
    return functools.reduce(mergeDicts, dep_dicts, {})

def theoremListToDependencyGraph(theorem_list):
    return nx.DiGraph(theoremListToDependencyDict(theorem_list))

d1 = {'a':{'b'}, 'b':{}}
d2 = {'a':{'b'},'b':{'c','d'},'c':set(),'d':set()}
assert(mergeDicts(d1,{}) == d1)
assert(mergeDicts({},d1) == d1)

theorem_list =  \
    [
        ['Top', ['Def','b',['c','d']], ['Def','a','b']],
        ['Top', ['Def','d','e'], ['Def','c','e'],
                ['Def','b',['App','c','d']], ['Def','a','b']]
    ]

assert(theoremListToDependencyDict(theorem_list) == d2)

#+END_SRC

**** Plot/Export graph for non-library theorems

#+BEGIN_SRC python :session :results output silent

def plotDependencyGraph(graph, outfile, label=False, figsize=(4,4)):
    assert(graph.order() != 0)
    plt.figure(figsize=figsize)
    nx.spring_layout(graph, k=5/math.sqrt(graph.order()))
    nx.draw(graph, with_labels=label)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)

def theoremNameToOutfile(theorem_name):
    return 'Images/' + theorem_name + '_dependencies.png'

def exportIndivResults(theorem_name, theorem, graph, depth):
    list_outfolder = "./ProofList/Individual/" + theorem_name
    graph_outfolder = "./Graphs/Individual/" + theorem_name
    if not os.path.exists(list_outfolder):
        os.mkdir(list_outfolder)
    if not os.path.exists(graph_outfolder):
        os.mkdir(graph_outfolder)
    with open(list_outfolder + "/d"+str(depth)+".txt",'w') as f:
        f.write(json.dumps(theorem))
    nx.write_adjlist(graph, graph_outfolder + "/d"+str(depth)+".txt")

def plotDepGraphFromTheoremName(theorem_name, depth=2, label=False, figsize=(4,4), export=False):
    outfile = theoremNameToOutfile(theorem_name)
    if not os.path.exists(outfile):
        theorem = theoremNameToLists(theorem_name, depth=depth)
        graph = theoremToDependencyGraph(theorem)
        if export:
            exportIndivResults(theorem_name, theorem, graph, depth)
        plotDependencyGraph(graph, outfile, label=label, figsize=figsize)


#+END_SRC

**** Plot/Export graph for library theorems

#+BEGIN_SRC python :session :results output silent

def libTheoremNameToLists(theorem_name, library_name, debug=False):
    theorem_location = './ProofTrees/StdLib/'+library_name
    with open(theorem_location + '/'+theorem_name+'.txt', 'r') as f:
        paren_string = f.read()
    if paren_string:
        return parenStringToLists('(Top ' + paren_string.strip() + ')', debug=debug)
    else:
        return []

def nameToStdLibTheorems(library_name, debug=False):
    lib_location = "./ProofTrees/StdLib/" + library_name
    if not os.path.exists(lib_location):
        subprocess.run(["./lib_to_trees.sh", library_name])
    theorem_names = list(map(lambda x: x[:-4], os.listdir(lib_location)))
    theorems = {}
    for theorem_name in theorem_names:
        unsub_theorem_def = libTheoremNameToLists(theorem_name, library_name, debug=debug)
        if unsub_theorem_def != []:
            theorems[theorem_name] = unsub_theorem_def
    return theorems

def libNameToOutfile(library_name):
    return 'Images/' + library_name + '_library_dependencies.png'

def exportLibResults(library_name, theorems, graph, depth):
    list_outfolder = "./ProofList/StdLib/" + library_name
    graph_outfolder = "./Graphs/StdLib/" + library_name
    if not os.path.exists(list_outfolder):
        os.mkdir(list_outfolder)
    if not os.path.exists(graph_outfolder):
        os.mkdir(graph_outfolder)
    for theorem_name, theorem_def in theorems.items():
        with open(list_outfolder + '/' + theorem_name + '.txt','w') as f:
            f.write(json.dumps(theorem_def))
    nx.write_adjlist(graph, graph_outfolder + '/' + library_name + '.txt')


def plotDepGraphFromLibraryName(library_name, depth=2, label=False, figsize = (8,6), export=False, debug=False):
    assert(library_name in os.listdir('/home/scottviteri/LocalSoftware/coq/theories'))
    outfile = libNameToOutfile(library_name)
    if not os.path.exists(outfile):
        theorems = nameToStdLibTheorems(library_name, debug=debug)
        graph = theoremListToDependencyGraph(theorems.values())
        if export:
            exportLibResults(library_name, theorems, graph, depth)
        plotDependencyGraph(graph, outfile, label=label, figsize=figsize)

#+END_SRC

#+RESULTS:

*** Plot dependency graphs for non-library theorems

**** ev_8

#+BEGIN_SRC python :session :results file
theorem_name = 'ev_8'
plotDepGraphFromTheoremName(theorem_name, label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/ev_8_dependencies.png]]

**** sqrt2_not_rational

#+BEGIN_SRC python :session :results file
theorem_name = 'sqrt2_not_rational'
plotDepGraphFromTheoremName(theorem_name, figsize = (8,6), label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/sqrt2_not_rational_dependencies.png]]

**** birthday_paradox

#+BEGIN_SRC python :session :results file
theorem_name = 'birthday_paradox'
plotDepGraphFromTheoremName(theorem_name, figsize = (8,6),label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/birthday_paradox_dependencies.png]]


Hypothesis about what is going on here:
 Library theorems have many more direct dependencies than the average Coq proof

**** bertrand_ballot

#+BEGIN_SRC python :session :results file
theorem_name = 'bertrand_ballot'
plotDepGraphFromTheoremName(theorem_name, figsize = (8,6), label=True)
theoremNameToOutfile(theorem_name)
#+END_SRC

#+RESULTS:
[[file:Images/bertrand_ballot_dependencies.png]]

*** Plot dependency graphs for libraries

**** Reals

#+BEGIN_SRC python :session :results file
library_name = "Reals"
plotDepGraphFromLibraryName(library_name, debug=True)
libNameToOutfile(library_name)
#+END_SRC

#+RESULTS:
[[file:Images/Reals_library_dependencies.png]]

**** Arith

#+BEGIN_SRC python :session :results file
library_name = "Arith"
plotDepGraphFromLibraryName(library_name)
libNameToOutfile(library_name)
#+END_SRC

#+RESULTS:
[[file:Images/Arith_library_dependencies.png]]

**** ZArith

#+BEGIN_SRC python :session :results file
library_name = "ZArith"
plotDepGraphFromLibraryName(library_name)
libNameToOutfile(library_name)
#+END_SRC

#+RESULTS:
[[file:Images/ZArith_library_dependencies.png]]


** Create Substituted Theorem Graphs
*** Plot sub graphs for non-library theorems
**** Sub tree to DAG transformation

#+BEGIN_SRC python :session :results file

even_8_alt_tree = theoremNameToLists('ev_8_alt')
sub_even_8_tree = replaceDefinitions(even_8_alt_tree)
printTree(sub_even_8_tree)

def successors(lst):
    return lst[1:]

def traverse(tree):
    frontier = [tree]
    depends_on = {}
    while frontier:
        current_node = frontier.pop(0)
        if isinstance(current_node, list):
            name = current_node[0]
            next_nodes = successors(current_node)
            next_names = [x[0] if isinstance(x,list) else x for x in next_nodes]
            if name in depends_on:
                depends_on[name] += next_names
            else:
                depends_on[name] = next_names
            frontier.extend(next_nodes)
        else:
            name = current_node
    return depends_on

deps = traverse(sub_even_8_tree)
plotDependencyGraph(nx.DiGraph(deps), 'Images/temp.png', label=True, figsize=(4,4))
'Images/temp.png'
#+END_SRC

#+RESULTS:
[[file:Images/temp.png]]

This is not what we want -- this is simply saying that many things are applied and such
Try with larger motifs.
 Accept incomplete 1 level mathces

#+BEGIN_SRC python :session :results output silent
def replaceSubstMotif(motif, tree):
    depends_on = {}
    h, t = tree[0], tree[1:]
    for x in t:
        if x == motif:
            if h in depends_on:
                depends_on[h] += ['motif_name']
            else:
                depends_on[h] = ['motif_name']

        elif isinstance(x, list):
            if h in depends_on:
                depends_on[h] += [x[0]]
            else:
                depends_on[h] = x[0]
            depends_on = mergeDicts(depends_on, replaceSubstMotif(motif, t))
        else:
            if h in depends_on:
                depends_on[h] += [x]
            else:
                depends_on[h] = [x]
    return depends_on

m = ['App',
        'ev_8_alt.add_even_even',
        '2',
        '2',
        'ev_8_alt.ev_2',
        'ev_8_alt.ev_2' ]

printTree(sub_even_8_tree)
print(replaceSubstMotif(m, sub_even_8_tree))

#+END+SRC



#+BEGIN_SRC python :session :results output silent


l = ['Definition',['b',['App','d','e']],
                  ['c',['App','d','e']]]

printTree(l)

getAdj = lambda l: (l[0], [x[0] if isinstance(x,list) else x for x in l[1:]])

print(getAdj(l))


def subTreeToDAG(sub_tree):
    """
    Base Case: ['App','d','e'] -> {'App': [['d','e']]}
    Ind Case: ['App', {'App': ['d','e']}] -> {'c': 'App', 'App': [['App'], ['d','e']]}
    """
    #if not isinstance(sub_tree,list):
    #    return sub_tree
    adj = {}
    h, t = sub_tree[0], sub_tree[1:]
    if isFlat(t):
        return {h:t}
    #rt, leaves = {getAdj(sub_tree)}
    #if leaves in adj[root]:
    adj = getAdj(sub_tree)
    return 1

# App could go to other things, so really a collection of all leaf lists
#create a new sub_graph, but in the form of a dictionary

# building up a dictionary of where root nodes could potentially move to next
# when I find that node eg App could move to same leaf set from different places,
#  then identify those in the output DAG

#+END_SRC
