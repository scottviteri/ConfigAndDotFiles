(+ 1 2)
(+ 1 2)
(bind-val myPI double 3.1415)

(bind-func circle_area
  (lambda (r:double)
    (* r r myPI)))

(println (circle_area 5.0))

(bind-func doughnut-area
  (lambda (r1 r2)
    (- (circle_area r1)
       (circle_area r2))))

(doughnut-area 5.0 2.5)

(now)

(sys:load "/home/scottviteri/LocalSoftware/Extempore-0.7.0-Ubuntu/extempore/libs/core/instruments.xtm")
(sys:load "/home/scottviteri/LocalSoftware/Extempore-0.7.0-Ubuntu/extempore/libs/core/instruments-scm.xtm")
(sys:load "/home/scottviteri/LocalSoftware/Extempore-0.7.0-Ubuntu/extempore/libs/external/instruments_ext.xtm")

(bind-instrument synth fmsynth_note_c fmsynth_fx)
(bind-func dsp:DSP
  (lambda (in time chan dat)
    (synth in time chan dat)))
(dsp:set! dsp)

(define play-seq
  (lambda ()
    (play-note (now) synth 60 100 10000)
    (play-note (+ (now) 22050) synth 64 100 10000)
    (play-note (+ (now) 44100) synth 67 100 10000)
    (play-note (+ (now) (+ 22050 44100)) synth 72 100 10000))
  )

(play-seq)

(define foo
  (lambda ()
    (play-note (now) synth 60 80 (/ *second* 4))
    (callback (+ (now) *second*) 'foo)))

(foo)

(define foo'
  (lambda ()
    (play-note (now) synth 60 100 (* *second* (random)))
    (callback (+ (now) *second*) 'foo')))

(foo')

(define loop
  (lambda (time)
    (play-note time synth 60 100 1.0)
    (callback (+ time 40000) 'loop (+ time 44100))))

(loop (now))

(sys:load "/home/scottviteri/LocalSoftware/Extempore-0.7.0-Ubuntu/extempore/libs/external/sndfile.xtm")

(bind-func organ_drone
  (let ((num_drawbars 9)
        ;; allocate memory for the oscillators and other bits and pieces
        (freq_ratio:SAMPLE* (zalloc num_drawbars))
        (drawbar_pos:i64* (zalloc num_drawbars))
        (tonewheel:[SAMPLE,SAMPLE,SAMPLE]** (zalloc num_drawbars))
        (i 0))
    ;; fill the allocated memory with the right values
    ;; drawbar frequencies as ratio of fundamental frequency
    (pfill! freq_ratio 0.5 1.5 1.0 2.0 3.0 4.0 5.0 6.0 8.0)
    ;; drawbar positions: 0 = min, 8 = max amplitude
    (pfill! drawbar_pos 8 8 8 0 0 0 0 0 0)
    ;; put an oscillator into each tonewheel position
    (dotimes (i num_drawbars)
          (pset! tonewheel i (osc_c 0.0)))
    (lambda (freq)
      (let ((sum 0.0))
        ;; loop over all the drawbars/tonewheels to get the sum
        (dotimes (i num_drawbars)
          (set! sum (+ sum (* (/ (convert (pref drawbar_pos i) SAMPLE) 8.0)
                              ((pref tonewheel i) 1.0
                               (* freq (pref freq_ratio i)))))))
        ;; normalise the sum by the number of drawbars
        (/ sum (convert num_drawbars SAMPLE))))))

(bind-func dsp:DSP
  (lambda (in time chan dat)
    (if (= chan 0)
        (organ_drone 440.0)
        (organ_drone (* 1.5 440.0)))))

(bind-func dsp:DSP
  (lambda (in time chan dat) 0.0))

(bind-func organ_fx 100000
  (let ((treml (osc_c 0.0))
        (tremr (osc_c 0.0))
        (trem_amp 0.1)
        (wet 0.5)
        (fb 0.5)
        (trem_freq .0))
    (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
      (cond ((= chan 0)
             (* in
                (+ 1.0 (treml trem_amp trem_freq))))
            ((= chan 1)
             (* in
                (+ 1.0 (tremr trem_amp (* 1.1 trem_freq)))))
            (else 0.0)))))

(bind-func organ_note_c
  (let ((num_drawbars:i64 9)
        (freq_ratio:SAMPLE* (zalloc num_drawbars))
        (drawbar_pos:SAMPLE* (zalloc num_drawbars)))
    (pfill! freq_ratio 0.5 1.5 1.0 2.0 3.0 4.0 5.0 6.0 8.0)
    (pfill! drawbar_pos 8. 8. 8. 0. 0. 0. 0. 0. 0.)
    (lambda (data:NoteInitData* nargs:i64 dargs:SAMPLE*)
      (let ((tonewheel:[SAMPLE,SAMPLE,SAMPLE]** (zalloc (* 2 num_drawbars)))
            (freq_smudge:SAMPLE* (zalloc num_drawbars))
            (i:i64 0))
        (dotimes (i num_drawbars)
          (pset! tonewheel (* i 2) (osc_c 0.0))       ;; left
          (pset! tonewheel (+ (* i 2) 1) (osc_c 0.0)) ;; right
          (pset! freq_smudge i (* 3.0 (random))))
        (lambda (time:i64 chan:i64 freq:SAMPLE amp:SAMPLE)
          (if (< chan 2)
              (let ((sum 0.0))
                (dotimes (i num_drawbars)
                  ;; (printf "i = %lld" i)
                  (set! sum (+ sum (* (/ (pref drawbar_pos i) 8.0)
                                      ((pref tonewheel (+ (* 2 i) chan))
                                       amp
                                       (+ (* freq (pref freq_ratio i))
                                          (pref freq_smudge i)))))))
                (/ sum (convert num_drawbars)))
              0.))))))

(bind-func ptr_test
  (lambda ()
    (let ((a:double* (zalloc)))
      (printf "address = %p\n" a))))

(ptr_test)

(bind-type point <double,double>)

(bind-func euclidian-distance
  (lambda (p1:point* p2:point*)
    (let ((dx:double (- (tref p2 0) (tref p1 0)))
          (dy:double (- (tref p2 1) (tref p1 1))))
      (sqrt (+ (* dx dx) (* dy dy))))))

(bind-func make-tuple
  (lambda (d1:double d2:double)
    (let ((t:<double,double>* (alloc)))
      (tfill! t d1 d2)
      t)))

(euclidian-distance (make-tuple 1.0 1.0) (make-tuple 2.0 2.0))

(bind-instrument organ organ_note_c organ_fx)

(sin 1.0)

(bind-func dsp
  (lambda (in:SAMPLE time:i64 chan:i64 data:SAMPLE*)
    (* .1 (sin (/ (* 2.0 3.1415               ;; 2pi(ish)
                     440.0                    ;; frequency (Hz)
                     (i64tof (% time 44100))) ;; time mod samplerate
                  44100.0)))))

(bind-func osc_c
  (lambda (phase)
    (lambda (amp freq:SAMPLE)
      (let ((incr (* 2.0 3.1415 (/ freq 44100.))))
        (set! phase (% (+ phase incr) (* 2.0 3.1415)))
        (* amp (sin phase))))))

(bind-val pi_ float 3.14159)

(bind-func sawd_c
  (lambda (phase)
    (lambda (amp freq:SAMPLE)
      (let ((incr (* 2.0 3.1415 (/ freq 44100.))))
        (set! phase (% (+ phase incr) (* 2.0 3.1415)))
        (cond ((< phase (/ pi_ 2.0)) (* amp phase))
              ((> phase (/ (* 3.0 pi_) 2.0)) (- amp (* amp (- phase (/ pi_ 2.0)))))
              (else (- (* amp phase) (* 4.0 amp))))))))


(bind-func dsp:DSP
  (let ((osc1 (saw_c 0.0))
        (osc2 (saw_c 0.0)))
    (lambda (in time chan dat)
      (+ (osc1 0.1 300.0)
         (osc2 0.1 200.0)))))

(bind-func dsp:DSP
  (let ((osc1 (osc_c 0.0))
        (osc2 (osc_c 0.0)))
    (lambda (in time chan dat)
      (+ (osc1 0.23 300.0)
         (osc2 0.23 200.0)))))

;(dsp:set! dsp)
(bind-func dsp:DSP
  (lambda (in time chan dat)
    ;; call the organ instrument closure
    (organ in time chan dat)))

(play-note (now) organ 65 160 44100)

;(bind-instrument synth synth_note_c synth_fx)


(bind-func saw_synth_note_c
  (lambda (data:NoteInitData* nargs:i64 dargs:SAMPLE*)
    (let ((sawl (saw_c 0.))
          (sawr (saw_c 0.)))
      (lambda (time:i64 chan:i64 freq:SAMPLE amp:SAMPLE)
        (cond ((= chan 0)
               (sawl amp freq))
              ((= chan 1)
               (sawr amp freq))
              (else 0.0))))))

(bind-func saw_synth_fx 200000 ;; extra memory for the delay lines
  (let ((delayl (delay_c 22050))
        (delayr (delay_c 22050)))
    (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*)
      (cond ((= chan 0)
             (delayl in 0.3 0.2))
            ((= chan 1)
             (delayr in 0.3 0.2))
            (else 0.0)))))


(bind-instrument saw_synth saw_synth_note_c saw_synth_fx)


(bind-func dsp:DSP
  (lambda (in time chan dat)
    (saw_synth in time chan dat)))

(play-note (now) saw_synth (random 60 80) 90 (* 1.0 *second*))

(define m3 3)
(define M3 4)
(define p5 7)
(define 5- 6)
(define 5+ 8)

(define chord
  (lambda (rt)
    (play-note (now) saw_synth rt 90 *second*)
    (play-note (now) saw_synth (+ rt M3) 90 *second*)
    (play-note (now) saw_synth (+ rt p5) 90 *second*)))

(chord 62)

(define chord
  (lambda (rt kind time)
    (cond ((eq? kind 'maj)
           (play-note time saw_synth rt 90 *second*)
           (play-note time saw_synth (+ M3 rt) 90 *second*)
           (play-note time saw_synth (+ p5 rt) 90 *second*))
          ((eq? kind 'min)
           (play-note time saw_synth rt 90 *second*)
           (play-note time saw_synth (+ m3 rt) 90 *second*)
           (play-note time saw_synth (+ p5 rt) 90 *second*))
          ((eq? kind 'dim)
           (play-note time saw_synth rt 90 *second*)
           (play-note time saw_synth (+ m3 rt) 90 *second*)
           (play-note time saw_synth (+ -5 rt) 90 *second*))
          ((eq? kind 'aug)
           (play-note time saw_synth rt 90 *second*)
           (play-note time saw_synth (+ M3 rt) 90 *second*)
           (play-note time saw_synth (+ 5+ rt) 90 *second*)))))

(chord 61 'maj (now))

(define chords
  (lambda (rt)
    (chord rt 'min (now))
    (chord rt 'maj (+ *second* (now)))
    (chord rt 'aug (+ (* 2 *second*) (now)))
    (chord rt 'dim (+ (* 3 *second*) (now)))))

(chords 60)
(chords 61)

(define melody (map (lambda (c)
                      (- (char->integer c) 24))
                    (string->list "lkjhgfdsa")))

(define loop
  (lambda (time pitch-list)
    (cond ((null? pitch-list) (println 'done))
          (else (play-note time saw_synth (car pitch-list) 120 5000)
                (loop (+ time (* *second* 0.25))
                      (cdr pitch-list))))))

(loop (now) melody)
(dotimes (i 20)
  (play-note (+ (now) (* i 5000)) saw_synth (+ 60 (modulo i 4)) 100 4000)
  (play-note (+ (now) (* i 5000)) saw_synth (+ 60 (modulo i 5)) 100 4000))

(let loop ((i 0))
  (play-note (+ (now) (* i 2500)) saw_synth (+ 60 i) 100 4000)
  (if (< i 9) (loop (+ i 2))))

(let loop ((scale '(0 2 4 5 7 9 11 12 11 9 7 5 4 2 0))
           (time 0))
  (play-note (+ (now) time) saw_synth (+ 60 (car scale)) 100 10000)
  (if (not (null? (cdr scale)))
      (loop (cdr scale) (+ time 11000))))

(let loop ((scale '(0 2 4 5 7 9 11 12))
           (dur '(22050 11025 11025 22050 11025 11025 44100 44100))
           (time 0))
  (play-note (+ (now) time) saw_synth (+ 60 (car scale)) 100 (car dur))
  (if (not (null? (cdr scale)))
      (loop (cdr scale) (cdr dur) (+ time (car dur)))))

(let loop ((chord '(0 4 7)))
  (play-note (now) saw_synth (+ 60 (car chord)) 80 44100)
  (if (not (null? (cdr chord)))
      (loop (cdr chord))))

(let loop ((scale '(0 4 7)))
  (cond ((null? scale) 'finished)
        (else (play-note (now) saw_synth (+ 60 (car scale)) 80 44100)
              (loop (cdr scale)))))

(map (lambda (p) (play-note (now) saw_synth p 80 44100))
     (list 60 63 67))

(map (lambda (p d)
       (play-note (+ (now) d) saw_synth p 80 (- 88200 d)))
     (list 60 64 67)
     (list 0 22050 44100))

(for-each
 (lambda (p d v)
   (play-note (+ (now) d) saw_synth p v (- 88200 d)))
 (list 60 64 67)
 (list 0 22050 44100)
 (list 120 100 80))

(define play-seq
  (lambda (time plst)
    (play-note time saw_synth (car plst) 100 11025)
    (if (not (null? (cdr plst)))
        (callback (+ time 10000) 'play-seq (+ time 11025) (cdr plst)))))

(play-seq (now) '(60 62 63 65 67 68 71 72))

(make-list-with-proc 4 (lambda (i) (random '(60 62 64 67 69))))
(make-list-with-proc 4 (lambda (x) x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Harmonizer ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (chord rt half-steps)
  (if (not (null? half-steps))
      (begin
        (play-note (now) saw_synth (+ rt (car half-steps)) 100 22050)
        (chord rt (cdr half-steps)))))

(chord 60 '(0 3 7 14))

(define (scale-chord time rt scale degrees)
  (if (not (null? degrees))
      (let* ((degree (- (car degrees) 1))
             (quot (quotient degree 7))
             (rem (remainder degree 7)))
        (begin
          (play-note time saw_synth
                     (+ rt
                        (list-ref scale rem)
                        (* 12 quot))
                     100 22050)
          (scale-chord time rt scale (cdr degrees))))))

(define major-scale '(0 2 4 5 7 9 11))
(define minor-scale '(0 2 3 5 7 9 11))
(define mel-minor-scale '(0 2 3 5 7 9 10))

(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
(append '(1 2 3) '(4 5))

(define (reverse lst)
  (define (reverse' l1 l2)
    (if (null? l1) l2 (reverse' (cdr l1) (cons (car l1) l2))))
  (reverse' lst '()))
(reverse '(1 2 3))

(define (append-reverse lst)
  (append lst (reverse lst)))

(play-seq (now) (map (lambda (x) (+ 60 x)) (append-reverse major-scale)))
(play-seq (now) (map (lambda (x) (+ 60 x)) (append-reverse minor-scale)))
(play-seq (now) (map (lambda (x) (+ 60 x)) (append-reverse mel-minor-scale)))

(scale-chord (now) 60 minor-scale '(1 3 5 7))

(define (scale-degree-to-midi rt scale degree)
  (let ((quot (quotient (- degree 1) 7))
        (rem (remainder (- degree 1) 7)))
    (+ rt (list-ref scale rem) (* 12 quot))))

(scale-degree-to-midi 60 major-scale 8)

(make-list-with-proc
 3
 (lambda (x) (+ 1 (* 2 x))))

(define (harmonize time melody scale num-extensions)
  (if (not (null? melody))
      (let ((degree (car melody))
            (extensions (make-list-with-proc
                         num-extensions
                         (lambda (x) (+ 1 (* 2 x))))))
        (begin
          (scale-chord time
                       60
                       scale
                       (map (lambda (x) (+ x degree)) extensions))
          (callback
           (+ time 11025)
           'harmonize
           (+ time 22050)
           (cdr melody)
           scale
           num-extensions)))))

(harmonize (now) '(6 7 8 7 6) major-scale 3)
(harmonize (now) '(1 2 3 2 1) minor-scale 3)
(harmonize (now) '(1 5 2 6 3 7) major-scale 4)

(scale-chord (now) 60 major-scale '(1 3 5 7))
(scale-chord (now) 67 major-scale '(1 3 5 7))
(scale-chord (now) 62 major-scale '(1 3 5 7))
(scale-chord (now) 69 major-scale '(1 3 5 7))

(define (rotate-right start)
  (let* ((next (+ start 7))
         (diff (- next 60)))
    (+ 60 (modulo diff 12))))

(rotate-right 60)
(rotate-right 73)

(define (rotate-left start)
  (let* ((next (- start 7))
        (diff (- next 60)))
    (+ 60 (modulo diff 12))))

(rotate-left 59)

(define (circle-of-fifths time start direction num)
  (if (> num 0)
      (begin
        (println start)
        (scale-chord time start major-scale '(1 3 5 7))
        (callback
         (+ time 11025)
         'circle-of-fifths
         (+ time 22050)
         ((if (eq? direction 'clock) rotate-right rotate-left) start)
         direction
         (- num 1)))))

(circle-of-fifths (now) 60 'clock 13)
(circle-of-fifths (now) 60 'counter 13)

(define (flip start)
  (let* ((next (+ start (* 7 7)))
         (diff (- next 60)))
    (+ 60 (modulo diff 12))))

(flip 60)
(flip 71)

(define (meander time start num)
  (if (> num 0)
      (begin
        (scale-chord time start major-scale '(3 7 9))
        (let ((rand (random)))
          (callback
           (+ time 11025)
           'meander
           (+ time 22050)
           (cond ((> rand .6) (rotate-right start))
                 ((< rand .4) (rotate-left start))
                 (else (flip start)))
           (- num 1))))))

(meander (now) 60 30)

; put melody in key
; have memory and prevent loops with markov
