import data.list.perm
import tactic.squeeze

-- Notice that we are importing something from mathlib.

variables {α : Type*} {β : Type*} {γ : Type*}

/-
This exercise has you unpacking the definition of a surjective function and
using it.
-/

open function


#print surjective


/-
Notice that given `f : α → β`, `hf : surjective f`, and `b : β`,
we have `hf b : ∃ x : α, y = f x`.

You can then use cases, the equation compiler, pattern matching, etc.
to unpack the existential quantifier.
-/

example {f : α → β} (hf : surjective f) (y : β) : ∃ x : α, y = f x :=
let ⟨x, hx⟩ := hf y in
⟨x, hx.symm⟩

/-
In the next exercise, it may be helpful to use `rw [comp]` to unfold a function composition `f ∘ g`, and the `dsimp` tactic to reduce a lambda.
Because they yield terms that are definitionally equivalent, they are
not needed in the next example, but you can see what they do.
-/

example (g : β → γ) (f : α → β) (a : α) (c : γ) (h : g (f a) = c) :
  (g ∘ f)(a) = c :=
begin
  rw [comp],
  dsimp,
  assumption
end

/-
Prove the following.
-/
#print surjective

lemma surjective_comp {g : β → γ} {f : α → β}
    (hg : surjective g) (hf : surjective f) :
  surjective (g ∘ f) :=
begin
  rw [comp],
  rw surjective,
  intros c,
  cases (hg c) with b hb,
  cases (hf b) with a ha,
  refine ⟨a, _⟩,
  rw ha,
  exact hb
end

#check @exists.elim
#check @congr_arg

lemma surjective_comp' {g : β → γ} {f : α → β}
    (hg : surjective g) (hf : surjective f) :
  surjective (g ∘ f) :=
λ (c : γ),
  (exists.elim (hg c)
    (λ b hbc,
      (exists.elim (hf b)
      (λ a hab,
        ⟨a, (show g (f a) = c, from (eq.trans (congr_arg g hab) hbc))⟩))))

/-
This is the insertion sort we wrote in class.
-/

namespace insertion_sort

def insert1 (a : nat) : list nat → list nat
| [] := [a]
| (b :: l) := if a ≤ b then a :: b :: l else b :: (insert1 l)

def sort : list nat → list nat
| [] := []
| (a :: l) := insert1 a (sort l)

/-
The next exercise asks you to prove that the sorted list is a permutation of
the original list. You can browse the permutation library, but the following
`#check`s and example show you what you need.
-/

open list

#print perm.skip
#print perm.trans
#print perm.swap
#check perm.refl
#check @perm.symm

example : [1, 2, 3] ~ [3, 2, 1] :=
calc
  [1, 2, 3] ~ [2, 1, 3] : by apply perm.swap
        ... ~ [2, 3, 1] : by { apply perm.skip, apply perm.swap }
        ... ~ [3, 2, 1] : by apply perm.swap

/-
Use these to prove the sorting assignment correct.
-/


theorem perm_insert1 (a : nat) : ∀ l, insert1 a l ~ a :: l
| []       := by refl
| (b :: l) :=
begin
  unfold insert1,
  split_ifs,
  {
    exact (perm.refl _),
  },
  {
    have hl : insert1 a l ~ a :: l, from perm_insert1 l,
    refine (perm.trans (perm.skip b hl) _),
    exact (perm.swap a b l)
  }
end


theorem perm_sort : ∀ l, sort l ~ l
| []       := by refl
| (a :: l) :=
begin
  rw sort,
  refine (perm.trans (perm_insert1 a (sort l)) _),
  apply perm.skip,
  exact (perm_sort l)
end

end insertion_sort

/-
On the previous assignment, you were asked to define the following
inductive type and evaluation function.
-/

inductive nat_term
| const : ℕ → nat_term
| var   : ℕ → nat_term
| plus  : nat_term → nat_term → nat_term
| times : nat_term → nat_term → nat_term

namespace nat_term

def eval (val : ℕ → ℕ) : nat_term → ℕ
| (const n)   := n
| (var n)     := val n
| (plus s t)  := eval s + eval t
| (times s t) := eval s * eval t

/-
Implement "constant fusion," a procedure that simplifies subterms like
5 + 7 to 12. Using the auxiliary function simp_const, define a function
"fuse", as follows. To simplify a plus or a times, we first simplify the
arguments recursively, and then apply simp_const to try to simplify the
result.

Notice that the equation compiler does a lot of work for us: it matches
the relevant cases, and leaves everything else alone. On the other hand,
to prove that it preserves values, we have to split on all the cases.
-/

def simp_const : nat_term → nat_term
| (plus (const n₁) (const n₂))  := const (n₁ + n₂)
| (times (const n₁) (const n₂)) := const (n₁ * n₂)
| e                             := e

theorem eval_simp_const (v : ℕ → ℕ) (e : nat_term) :
  eval v (simp_const e) = eval v e :=
by cases e with n n s t s t; simp [eval, simp_const]; cases s; cases t;
    simp [eval, simp_const]

def fuse : nat_term → nat_term
| (plus s t)  := plus (fuse s) (fuse t)
| (times s t) := times (fuse s) (fuse t)
| e           := simp_const e

theorem fuse_eq (v : ℕ → ℕ) : ∀ e : nat_term, eval v (fuse e) = eval v e :=
begin
  intros e,
  induction e with n n s t hs ht s t hs ht;
  try { rw fuse, exact (eval_simp_const v _)}; { rw [fuse, eval, hs, ht, eval] }
end


end nat_term

/-
The last two exercises are open-ended, and are entirely optional!
-/

/-
This is the more efficient way to define list reversal.
-/

namespace list

def rev_aux : list α → list α → list α
| []     t := t
| (a::s) t := rev_aux s (a::t)

def rev (l : list α) : list α := rev_aux l nil

/-
Prove the following. (Actually, `list.reverse` is implemented this way
in Lean's library, so you can look there for guidance.)
-/

theorem rev_nil : rev (@nil α) = [] := rfl

theorem rev_aux_cons : ∀ (a : α) (l1 : list α) (l2 : list α),
  rev_aux l1 l2 ++ [a] = rev_aux l1 (l2 ++ [a]) :=
begin
  intros a l1,
  induction l1 with h t ih,
  {
    intros l2, refl,
  },
  {
    intros l2,
    repeat {rw rev_aux},
    rw (ih (h :: l2)),
    rw cons_append
  }
end


theorem rev_cons : ∀ (a : α) (t : list α), rev (a :: t) = rev t ++ [a] :=
begin
  intros a t,
  induction t with h l ih,
  { refl },
  {
    simp only [*, rev, rev_aux],
    exact (rev_aux_cons a l [h]).symm,
  }
end

theorem rev_singleton : ∀ (a : α), rev [a] = [a] :=  by {intros a; refl}


theorem rev_append : ∀ (l1 : list α) (l2 : list α), rev (l1 ++ l2) = rev l2 ++ rev l1
| [] l2 := by rw [nil_append, rev_nil, append_nil]
| (h :: t) l2 := by { simp only [cons_append, rev_cons],
                      rw [←append_assoc, (rev_append t l2)] }


theorem rev_rev : ∀ l : list α, rev (rev l) = l
| [] := rfl
| (h :: l) := by {rw [rev_cons, (rev_append (rev l) [h]), rev_singleton, (rev_rev l)],
                  refl}


end list

/-
Here is a sort procedure using binary search trees.
-/

def nondecreasing : list nat → bool
| []            := tt
| [a]           := tt
| (a :: b :: l) := (a ≤ b) && nondecreasing (b :: l)

inductive bst
| nil : bst
| node : ℕ → bst → bst → bst

namespace bst

def to_list_aux : bst → list nat → list nat
| bst.nil            l := l
| (bst.node n b₁ b₂) l := to_list_aux b₁ (n :: to_list_aux b₂ l)

def to_list (b : bst) := to_list_aux b []

def insert (n : nat) : bst → bst
| nil := node n nil nil
| (node m b₁ b₂) :=
  if n ≤ m then node m (insert b₁) b₂ else node m b₁ (insert b₂)

def from_list : list nat → bst
| [] := nil
| (a :: l) := insert a (from_list l)

def sort (l : list ℕ) := to_list (from_list l)

#eval to_list (node 5 (node 3 nil nil) (node 7 nil nil))

#eval sort [5,2,8,2,4,5,7,2,1,1]

/-
Prove the the result is sorted!
-/

#print bool.coe_sort_tt

theorem nondecreasing_sort : ∀ l : list ℕ, nondecreasing (sort l) :=
begin
  intros l,
  induction l with h t ih,
  {
    rw [sort, from_list, to_list, to_list_aux, nondecreasing],
    simp [bool.coe_sort_tt]
  },
  {
    rw sort, rw from_list,
    induction (from_list t) with n b1 b2 ihb1 ihb2,
    {
      rw [insert, to_list, to_list_aux, to_list_aux, to_list_aux, nondecreasing],
      simp [bool.coe_sort_tt]
    },
    {
      rw insert,
      split_ifs with hn,
      {
        rw to_list, rw to_list_aux,
      }
    }
  }

end

end bst
