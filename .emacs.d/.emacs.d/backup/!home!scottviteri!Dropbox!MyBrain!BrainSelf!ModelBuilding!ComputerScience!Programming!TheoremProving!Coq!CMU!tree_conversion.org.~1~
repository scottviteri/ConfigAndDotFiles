#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
   #+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

Goal is to create a compression of proof trees by finding motifs and pulling them out as separate trees.

First, grab some sample proof trees.

#+BEGIN_SRC python :session
s1 = '(Definition Top.ev_4 (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name ev) 2) (Construct (Name nat) 1) (Construct (Name ev) 1))))'
s2 = '(Definition Top.ev_8 (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))) (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name ev) 2) (Construct (Name nat) 1) (Construct (Name ev) 1))))))'
#+END_SRC

#+RESULTS:

We will need to parse these into a form that python can more directly read.

I am using a list of lists, where [A,B,[C,D]] represents
 A
 |\
 B C
   |
   D

#+BEGIN_SRC python :session :results output

import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json

def push(obj, l, depth):
    while depth:
        l = l[-1]
        depth -= 1
    l.append(obj)


def stringToLists(s):
    s = s[1:-1]
    groups = []
    depth = 0
    try:
        word = ''
        for char in s:
            if char == '(':
                push([], groups, depth)
                depth += 1
            elif char == ')':
                if word:
                    push(word, groups, depth)
                    word = ''
                depth -= 1
            elif char == ' ':
                if word:
                    push(word, groups, depth)
                    word = ''
            else:
                word += char
    except IndexError:
        raise Exception('Parentheses mismatch')
    if depth > 0:
        raise Exception('Parentheses mismatch')
    else:
        return groups


def focusToNewLetters(focus_string):
    if focus_string[1] == '(': return '['
    elif focus_string[1] == ')': return ']'
    elif focus_string[1] == ' ': return ','
    if focus_string[1].isalnum() \
        and (focus_string[0] == '(' or focus_string[0] == ' ') \
        and (focus_string[2] == ')' or focus_string[2] == ' '):
        return '\"'+focus_string[1]+'\"'
    if focus_string[1].isalnum() and (focus_string[0] == '(' or focus_string[0] == ' '):
        return '\"'+focus_string[1]
    if focus_string[1].isalnum() and (focus_string[2] == ')' or focus_string[2] == ' '):
        return focus_string[1]+'\"'
    return focus_string[1]


def parse(filename):
    accum = ''
    focus = "   "
    with open(filename,"r") as f:
        while 1:
            c = f.read(1)
            if not c: break
            focus = focus[1:] + c
            accum += focusToNewLetters(focus)
    return accum[1:]

def getParseList(filename):
    return ast.literal_eval(parse(filename))

print(stringToLists('(a b (c d es))'))
print()
print(s1)
print()

l1 = stringToLists(s1)
print(l1)
l1_from_file = parse('../100FamousProofs/Proofs/ev_4.txt')
print(l1_from_file)
#+END_SRC


#+RESULTS:
: ['a', 'b', ['c', 'd', 'es']]
:
: (Definition Top.ev_4 (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name ev) 2) (Construct (Name nat) 1) (Construct (Name ev) 1))))
:
: ['Definition', 'Top.ev_4', ['App', ['Construct', ['Name', 'ev'], '2'], ['App', ['Construct', ['Name', 'nat'], '2'], ['App', ['Construct', ['Name', 'nat'], '2'], ['Construct', ['Name', 'nat'], '1']]], ['App', ['Construct', ['Name', 'ev'], '2'], ['Construct', ['Name', 'nat'], '1'], ['Construct', ['Name', 'ev'], '1']]]]
: ["Definition","Top.ev_4",["App",["Construct",["Name","ev"],"2"],["App",["Construct",["Name","nat"],"2"],["App",["Construct",["Name","nat"],"2"],["Construct",["Name","nat"],"1"]]],["App",["Construct",["Name","ev"],"2"],["Construct",["Name","nat"],"1"],["Construct",["Name","ev"],"1"]]]]

Want to convert from nested list format to [(parent, name, id)] format.
It will be convenient to have ids strictly decrease as we go down a tree,
  and one way we can do this is by labeling the nodes in BFS order.

In order to do this, we'll first need to build up some helper functions to deal with nested lists.

#+BEGIN_SRC python :session :results output

def memoize(f):
    memo = {}
    def helper(x):
        immutable_x = pickle.dumps(x)
        if immutable_x not in memo:
            memo[immutable_x] = f(x)
        return memo[immutable_x]
    return helper

def isFlat(l):
    return not any(filter(lambda x: isinstance(x,list), l))

def add1(l):
    """ Adds 1 to each element in a nested numerical array
    Example: add1([[1,2,3],4,5])
    # base: [1,2,3] -> [2,3,4]
    # ind_step: [[2,3,4],4,5] -> [[2,3,4],5,6]
    """
    if isFlat(l): # base case
        return list(map(lambda x:x+1, l))
    else: # inductive step
        return list(map(lambda x: add1(x) if isinstance(x,list) else x+1, l))

assert(add1([1,2,3]) == [2,3,4])
assert(add1([[1,2,3],4,5]) == [[2,3,4],5,6])

def nestedMap(f,l):
    """ Map f over a nested list """
    if isFlat(l):
       return list(map(f,l))
    else:
       return list(map(lambda x: nestedMap(f,x) if isinstance(x,list) else f(x), l))

assert(nestedMap(lambda x:x+1, [[1,2,3],4,5]) == [[2,3,4],5,6])

def add1ToEndOfTuple(l):
   """ Adds 1 to the first tuple element in a nested tuple array """
   # [[(0,1),(0,2),(0,3)],(0,4),(0,5)] -> [[(1,1),(1,2),(1,3)],(1,4),(1,5)]
   return nestedMap(lambda x: (*x[:-1], x[-1]+1), l)

assert(add1ToEndOfTuple([[(1,0),(2,0),(3,0)],(4,0),(5,0)]) == [[(1,1),(2,1),(3,1)],(4,1),(5,1)])

def nestedMapListFxn(f,l):
   if isFlat(l): return f(l)
   else: return f([f(x) if isinstance(x,list) else x for x in l])

print(nestedMapListFxn(lambda l:l[::-1], [[1,2],3,[4,5]]))

#+END_SRC

#+RESULTS:
: [[5, 4], 3, [2, 1]]

labelDepth cannot be written in terms of nestedMap or nestedMapListFxn
 b/c it has different behavior at the flat list and nested list levels

#+BEGIN_SRC python :session :results output

def labelDepth(l): # takes non-empty list of lists, where 1st element is not a list
    """ Labels each element of nested list with tree depth
    # labelDepth(['e','e','e']) -> [('e',0),('e',1),('e',1)]
    # labelDepth(['e',['e','e','e'],'e']) -> [('e',0),[('e',1),('e',2),('e',2)],('e',2)]
    """
    h, t = l[0], l[1:] # b/c non-empty
    if isFlat(l): # base case
        # ['e','e','e'] -> [('e',0),('e',1),('e',1)]
        return [(h,0)] + [(x,1) for x in t]
    else: # inductive step
        # [ 'e'   ,[('e',0),('e',1),('e',1)], 'e'   ] ->
        # [('e',0),[('e',1),('e',2),('e',2)],('e',1)]
        return [(h,0)] +  [add1ToEndOfTuple(labelDepth(x)) \
                         if isinstance(x, list) else (x,1) for x in t]

assert(labelDepth(['e','e','e']) == [('e',0),('e',1),('e',1)])
assert(labelDepth(['e',['e','e','e'],'e']) == [('e',0),[('e',1),('e',2),('e',2)],('e',1)])

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

def indicatorFxn(prop, x): return 1 if prop(x) else 0

def countProperty(prop, l):
    # (lambda x:x==5) -> [5,[2,5],5] -> 3
    if isFlat(l): return len(list(filter(prop,l)))
    else:
        return sum([countProperty(prop,x) if isinstance(x,list)
                else indicatorFxn(prop,x) for x in l])

assert(countProperty(lambda x:x==5, [5,2,5]) == 2)
assert(countProperty(lambda x:x==5, [5,[2,5],5]) == 3)

def accumulate(start,l,f):
   total = start
   for x in l:
      total = f(total,x)
      yield total

def isEmpty(l): return not l

def label(prop, l, prev_count=-1, withTuples=False): # [2,1,1] -> [2,(1,0),(1,1)]
   if isEmpty(l): # base case : [] -> []
       return l
   else: # ind_step : (2 :: [1,1]) -> (2 :: [(1,0),(1,1)])
       h,t=l[0],l[1:]
       if prop(h):
          transformed_head = [(*h, prev_count+1)] if withTuples else [(h, prev_count+1)]
          prev_count += 1
       else:
          transformed_head = [h]
       return transformed_head + label(prop, t, prev_count, withTuples=withTuples)

assert(label(lambda x:x==1, []) == [])
assert(label(lambda x:x==1, [2,1,1]) == [2,(1,0),(1,1)])

def augWithCountProperty(prop,l,prev_count=-1,withTuples=False):
    # (lambda x:x==1) -> [1,[2,1,1],1] -> [(1,0),[2,(1,1),(1,2)],(1,3)]
    if isFlat(l): # base case
       # [2,1,1] -> [2,(1,0),(1,1)]
       return label(prop, l, prev_count, withTuples)
    else: #ind_step
       # [1,[2,(1,0),(1,1)],1] -> [(1,0),[2,(1,1),(1,2)],(1,3)]
       outlst = []
       for x in l:
           if isinstance(x,list):
               outlst.append(augWithCountProperty(prop,x,prev_count,withTuples))
               prev_count += countProperty(prop, x)
           else:
               if prop(x):
                   outlst.append((*x,prev_count+1) if withTuples else (x,prev_count+1))
                   prev_count += 1
               else:
                   outlst.append(x)
       return outlst

assert(augWithCountProperty(lambda x:x==1, [2,1,1]) == [2,(1,0),(1,1)])

assert(augWithCountProperty(lambda x:x==1, [ 1   ,[2, 1   , 1   ], 1   ])
                                   == [(1,0),[2,(1,1),(1,2)],(1,3)])

assert(augWithCountProperty(lambda x:x[0]==1,
                            [(1,0),[(2,0),(1,0),(1,0)],(1,0)],
                            withTuples=True)
      == [(1,0,0),[(2,0),(1,0,1),(1,0,2)],(1,0,3)])

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

def nestedMax(l):
   return nestedMapListFxn(lambda x: max(x), l)

def nestedMaxDepth(l):
   # [('e',0),[('e',1),('e',2),('e',2)],('e',2)] -> 2
   if isFlat(l):
       return max(l, key=lambda el: el[1])
   else:
       return max([nestedMaxDepth(x) if isinstance(x,list) else x for x in l], key=lambda el: el[1])

def getDepth(l): return l[1]
def getBFSCount(l): return l[2]

def nestedMaxBFSCountWithDepth(l, depth):
   return getBFSCount(
         nestedMapListFxn(lambda x: max(filter(lambda y: getDepth(y)==depth, x),
                          key=lambda el: getBFSCount(el)), l))

assert(nestedMax([3,[1,4],2]) == 4)
assert(getDepth(nestedMaxDepth([('e',0),[('e',1),('e',2),('e',2)],('e',1)])) == 2)
assert(nestedMaxBFSCountWithDepth([('e',0),[('e',1,0),('e',2),('e',2)],('e',1,1)],1) == 1)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

#cannot do by recursion on list level,
# since counts have dependencies outside of their local list
def numberBFS(l, start_id=0): # takes non-empty lists of tuple list, where 1st element is tuple
    """ Labels each element of a nested list with BFS ordering
    numberBFS(['e','e','e']) == [('e',0),('e',1),('e',2)]
    numberBFS(['e',['e','e','e'],'e']) == [('e',0),[('e',1),('e',3),('e',4)],('e',2)]
    """
    aug_lst = labelDepth(copy.deepcopy(l))
    prev_count = -1
    for depth in range(getDepth(nestedMaxDepth(aug_lst))+1):
        aug_lst = augWithCountProperty(prop=(lambda x: getDepth(x) == depth),
                                       l=aug_lst,
                                       prev_count=prev_count,
                                       withTuples=True)
        prev_count += countProperty(lambda x: depth==getDepth(x), aug_lst)

    return nestedMap(lambda x:(x[0],x[2]+start_id), aug_lst)

#def numberDictBFS(l, start_id=0):
#    # numberBFS({'a':{'b':{},'c':{}}, 'd':{}}) = {('a',0):0}


assert(numberBFS(['e','e','e']) == [('e',0),('e',1),('e',2)])
assert(numberBFS(['e',['e','e','e'],'e']) == [('e',0),[('e',1),('e',3),('e',4)],('e',2)])

aug_l1 = numberBFS(l1)
print(aug_l1)
print(numberBFS(l1, 3))

#+END_SRC

#+RESULTS:
: [('Definition', 0), ('Top.ev_4', 1), [('App', 2), [('Construct', 3), [('Name', 6), ('ev', 13)], ('2', 7)], [('App', 4), [('Construct', 8), [('Name', 14), ('nat', 24)], ('2', 15)], [('App', 9), [('Construct', 16), [('Name', 25), ('nat', 32)], ('2', 26)], [('Construct', 17), [('Name', 27), ('nat', 33)], ('1', 28)]]], [('App', 5), [('Construct', 10), [('Name', 18), ('ev', 29)], ('2', 19)], [('Construct', 11), [('Name', 20), ('nat', 30)], ('1', 21)], [('Construct', 12), [('Name', 22), ('ev', 31)], ('1', 23)]]]]
: [('Definition', 3), ('Top.ev_4', 4), [('App', 5), [('Construct', 6), [('Name', 9), ('ev', 16)], ('2', 10)], [('App', 7), [('Construct', 11), [('Name', 17), ('nat', 27)], ('2', 18)], [('App', 12), [('Construct', 19), [('Name', 28), ('nat', 35)], ('2', 29)], [('Construct', 20), [('Name', 30), ('nat', 36)], ('1', 31)]]], [('App', 8), [('Construct', 13), [('Name', 21), ('ev', 32)], ('2', 22)], [('Construct', 14), [('Name', 23), ('nat', 33)], ('1', 24)], [('Construct', 15), [('Name', 25), ('ev', 34)], ('1', 26)]]]]


#+BEGIN_SRC python :session :results output

def tupleTreeFromAugTree(l):
    """ Takes BFS labeled nested list, outputs (parent, kind, id) form """
    # [('e',0),[('e',1),('e',2)]] -> [(None,'e',0), (0,'e',1), (1,'e',2)]
    #print(l)
    if isFlat(l): #[('e',1),('e',2)] -> [(None,'e',1),(1,'e',2)]
        h,t=l[0],l[1:]
        return [(None,*h)] + [(h[1],*x) for x in t]
    else: # [('e',0),[(None,'e',1),(1,'e',2)]] -> [(None,'e',0),(0,'e',1), (1,'e',2)]
        outlst = [(None,*l[0])]
        parent_id = l[0][1]
        for x in l[1:]:
            if isinstance(x,list):
                tuples = tupleTreeFromAugTree(x)
                h,t=tuples[0],tuples[1:]
                outlst.append((parent_id,*h[1:]))
                outlst.extend(t)
            else:
                outlst.append((parent_id, *x))
        return outlst

def tupleTreeFromList(lst, start_id=0):
    return set(tupleTreeFromAugTree(numberBFS(lst, start_id)))

def stringToTupleTree(s):
    return tupleTreeFromList(stringToLists(s))

assert(tupleTreeFromAugTree([('e',1),('e',2)]) == [(None,'e',1),(1,'e',2)])
assert(tupleTreeFromAugTree([('e',0),[('e',1),('e',2)]]) == [(None,'e',0), (0,'e',1), (1,'e',2)])

tt = set(tupleTreeFromAugTree(aug_l1))
print(tt)
print()

print(l1)
print(tupleTreeFromList(l1,3))

#+END_SRC


