#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

Goal is to create a compression of proof trees by finding motifs and pulling them out as separate trees.

First, grab some sample proof trees.

#+BEGIN_SRC python :session
even_4_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2))'
even_8_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2)) (Definition Top.ev_8 (App ev_SS (App S (App S (App S (App S (App S (App S O)))))) (App ev_SS (App S (App S (App S (App S O)))) Top.ev_4)))'
#+END_SRC

#+RESULTS:

We will need to parse these into a form that python can more directly read.

I am using a list of lists, where [A,B,[C,D]] represents
 A
 |\
 B C
   |
   D

#+BEGIN_SRC python :session :results output

import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json
import functools

def push(obj, l, depth):
    while depth:
        l = l[-1]
        depth -= 1
    l.append(obj)


def stringToLists(s):
    s = s[1:-1]
    groups = []
    depth = 0
    try:
        word = ''
        for char in s:
            if char == '(':
                push([], groups, depth)
                depth += 1
            elif char == ')':
                if word:
                    push(word, groups, depth)
                    word = ''
                depth -= 1
            elif char == ' ':
                if word:
                    push(word, groups, depth)
                    word = ''
            else:
                word += char
    except IndexError:
        raise Exception('Parentheses mismatch')
    if depth > 0:
        raise Exception('Parentheses mismatch')
    else:
        return groups


def focusToNewLetters(focus_string):
    if focus_string[1] == '(': return '['
    elif focus_string[1] == ')': return ']'
    elif focus_string[1] == ' ': return ','
    if focus_string[1].isalnum() \
        and (focus_string[0] == '(' or focus_string[0] == ' ') \
        and (focus_string[2] == ')' or focus_string[2] == ' '):
        return '\"'+focus_string[1]+'\"'
    if focus_string[1].isalnum() and (focus_string[0] == '(' or focus_string[0] == ' '):
        return '\"'+focus_string[1]
    if focus_string[1].isalnum() and (focus_string[2] == ')' or focus_string[2] == ' '):
        return focus_string[1]+'\"'
    return focus_string[1]


def isFlat(l):
    return not any(filter(lambda x: isinstance(x,list), l))

def concat(lst_of_lsts):
    return functools.reduce(lambda x,y:x+y, lst_of_lsts, [])

def printTreeHelper(tree):
    """ Prints tree by prepending '+---' to each layer
    Example: printTreeHelper(['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']])
    # base: ['App', 'ev_SS', 'O', 'ev_0'] -> ['App', '+---ev_SS', '+---O', '+---ev_0']
    # ind_step: ['Definition', 'Top.ev_2', ['App', '+---ev_SS', '+---O', '+---ev_0']]
    #  -> ['Definition', '+---Top.ev_2', '+---App', '+---+---ev_SS', '+---+---O', '+---+---ev_0']]
    """
    h,t = tree[0], tree[1:]
    if not isinstance(tree, list):
        assert(isinstance(tree, str))
        return [tree]
    if isFlat(tree):
        return [h] + list(map(lambda x: "+---"+x, t))
    return [h] + concat([list(map(lambda x: "+---"+x, printTreeHelper(x))) for x in t])

def printTree(tree):
    for x in printTreeHelper(tree):
        print(x)



# let search_val be a flat list
def replaceFlatList(lst_of_lsts, search_val, replace_val):
    l = []
    for x in lst_of_lsts:
        if search_val == x:
            l.append(replace_val)
        else:
            if isinstance(x,list):
                if isFlat(x):
                    l.append(x)
                else:
                    l.append(replaceFlatList(x, search_val, replace_val))
            else:
                l.append(x)
    return l

def subNats(lst_of_lsts):
    l = replaceFlatList(lst_of_lsts, ['App','S','O'], '1')
    last_l = None
    n = 1
    while last_l != l:
       last_l = l
       l = replaceFlatList(l, ['App','S',str(n)], str(n+1))
       n += 1
    return l


def parenStringToLists(string, is_filename=False):
    accum = ''
    focus = "   "
    if is_filename:
        with open(string, 'r') as f:
            paren_string = f.read()[:-1]
    else:
        paren_string = string
    rooted_paren_string = '(Top ' + paren_string + ')'
    for char in rooted_paren_string:
        focus = focus[1:] + str(char)
        accum += focusToNewLetters(focus)
    focus = focus[1:] + str(char)
    accum += focusToNewLetters(focus)
    return subNats(json.loads(accum[1:]))

print(parenStringToLists('(a b (c d e))'))
print()

l1_from_file = parenStringToLists('../100FamousProofs/Proofs/ev_4.txt', True)
print(l1_from_file)

l1 = parenStringToLists(even_4_string)
assert(l1 == l1_from_file)

#+END_SRC

#+RESULTS:
: ['Top', ['a', 'b', ['c', 'd', 'e']]]
:
: ['Top', ['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']], ['Definition', 'Top.ev_4', ['App', 'ev_SS', '2', 'Top.ev_2']]]

#+BEGIN_SRC python :session

def recur(lst, out_file, count=0):
    if count == 0:
        out_file.write('None ' + str(lst[0]) + ' '+ str(count) +'\n')
        #print(None, lst[0], count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
    prev = count
    for unit in lst[1:]:
        count += 1
        if isinstance(unit,list):
            out_file.write(str(prev) + ' ' + str(unit[0]) + ' '+ str(count) +'\n')
            #print(prev, unit[0], count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
        else:
            out_file.write(str(prev) + ' ' + str(unit) + ' '+ str(count) +'\n')
            #print(prev, unit, count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
        if isinstance(unit, list):
            count = recur(unit, out_file, count)
    return count


with open('out.txt','w') as f:
    recur(['A','B',['C','D','E']], f)

with open('out.txt','r') as f:
    out = f.read()
    assert([len(l.split(' ')) == 3 for l in out.split('\n')[:-1]])
    print(out)

#+END_SRC

#+RESULTS:
: 4


Want to convert from nested list format to [(parent, name, id)] format.
It will be convenient to have ids strictly decrease as we go down a tree,
  and one way we can do this is by labeling the nodes in BFS order.

In order to do this, we'll first need to build up some helper functions to deal with nested lists.

#+BEGIN_SRC python :session

def evalTuple(tuple):
    return (eval(tuple[0]),tuple[1],eval(tuple[2]))

def loadTupleTreeFromFile(filename):
    with open(filename, "r") as f:
        tuple_strings = f.readlines()[::-1]
    tuple_tree = set([evalTuple(tuple(s[:-1].split(" "))) for s in tuple_strings])
    return tuple_tree


def genTupleTree(string, is_filename=False):
    lstOfLsts = parenStringToLists(string, is_filename)
    with open('out.txt','w') as f:
        c = recur(lstOfLsts, f)
    return loadTupleTreeFromFile('out.txt')

#assert(genTupleTree(even_4_string) == genTupleTree('../100FamousProofs/Proofs/ev_4.txt',True))

even_4_tree = parenStringToLists('../100FamousProofs/Proofs/ev_4.txt', True)
even_8_tree = parenStringToLists('../100FamousProofs/Proofs/ev_8.txt', True)
sqrt2_tree = parenStringToLists('../100FamousProofs/Proofs/sqrt2.txt', True)

print(even_8_tree)
#+END_SRC

#+RESULTS:



#+RESULTS:

#+BEGIN_SRC python :session

#now sub in definitions


def replaceVal(lst_of_lsts, search_val, replace_val):
    """ similar to subRec, but search target is a single value """
    l = []
    for x in lst_of_lsts:
        if instance(x,list):
            l.append(replaceVal(x, search_val, replace_val))
        else:
            if search_val == x:
                l.append(replace_val)
            else:
                l.append(x)
    return l

def replaceVals(lst_of_lsts, search_replace_dict):
    """ similar to replaceVal, but multiple search targets with different replace_vals """
    l = []
    for x in lst_of_lsts:
        if isinstance(x,list):
            l.append(replaceVals(x, search_replace_dict))
        else:
            if x in search_replace_dict:
                l.append(search_replace_dict[x])
            else:
                l.append(x)
    return l

def accumMatches(lst_of_lsts, test):
    l = []
    for x in lst_of_lsts:
        if isinstance(x, list):
            l.extend(accumMatches(x, test))
        else:
            if test(x):
                l.append(x)
    return l

def replaceDefinitions(lst_of_lsts, max_depth=math.inf):
    orig_tree = lst_of_lsts[-1]
    replace_strings = accumMatches(orig_tree[2], lambda x: x[:4] == "Top.")
    def_to_subtree = {x[1]:x for x in lst_of_lsts}
    depth = 0
    l = []
    while replace_strings and depth < max_depth:
        search_replace_dict = {k:def_to_subtree[k] for k in def_to_subtree if k in replace_strings}
        orig_tree = replaceVals(orig_tree, search_replace_dict)
        depth += 1
        replace_strings = concat([accumMatches(subtree[2], lambda x: x[:4] == "Top.")
                                  for subtree in search_replace_dict.values()])
    return orig_tree

printTree(replaceDefinitions(even_8_tree,2))

#+END_SRC


#+BEGIN_SRC python :session
def printTreeHelper(tree):
    """ Prints tree by prepending '+---' to each layer
    Example: printTreeHelper(['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']])
    # base: ['App', 'ev_SS', 'O', 'ev_0'] -> ['App', '+---ev_SS', '+---O', '+---ev_0']
    # ind_step: ['Definition', 'Top.ev_2', ['App', '+---ev_SS', '+---O', '+---ev_0']]
    #  -> ['Definition', '+---Top.ev_2', '+---App', '+---+---ev_SS', '+---+---O', '+---+---ev_0']]
    """
    h,t = tree[0], tree[1:]
    if not isinstance(tree, list):
        assert(isinstance(tree, str))
        return [tree]
    if isFlat(tree):
        return [h] + list(map(lambda x: "+---"+x, t))
    return [h] + concat([list(map(lambda x: "+---"+x, printTreeHelper(x))) for x in t])

def sumLsts(lsts):
    return list(map(sum, zip(*lsts)))

def countNodesAtDepths(tree):
    """ Counts num nodes at each depth
    Example: countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']])
    # base: ['c','d','e'] -> [1,2]
    # ind_step: ['a', 'b', [1,2], [1,2]] -> [1,3,4]
    """
    h,t = tree[0], tree[1:]
    if isFlat(tree): return [1,len(tree)-1]
