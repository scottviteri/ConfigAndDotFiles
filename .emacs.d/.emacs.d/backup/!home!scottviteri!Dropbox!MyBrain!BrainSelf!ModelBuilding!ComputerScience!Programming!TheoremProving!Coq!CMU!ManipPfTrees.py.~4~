#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree}

* Manip Proof Trees

  Goal is to create a compression of proof trees by finding motifs and pulling them out as separate trees.


\begin{equation}
\Tree [.S when [.NP the cat ].NP sleeps ]
\begin{equation}

%#+ATTR_LATEX :environment equation
%#+BEGIN_EXAMPLE :results output raw graphics :file test2.png
%fdsaf
%#+END_EXAMPLE


#+BEGIN_SRC python :session
s1 = '(Definition Top.ev_4 (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name ev) 2) (Construct (Name nat) 1) (Construct (Name ev) 1))))'
s2 = '(Definition Top.ev_8 (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))) (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (App (Construct (Name ev) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name ev) 2) (Construct (Name nat) 1) (Construct (Name ev) 1))))))'
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

def push(obj, l, depth):
    while depth:
        l = l[-1]
        depth -= 1
    l.append(obj)

def parse_parentheses(s):
    s = s[1:-1]
    groups = []
    depth = 0
    try:
        word = ''
        for char in s:
            if char == '(':
                push([], groups, depth)
                depth += 1
            elif char == ')':
                if word:
                    push(word, groups, depth)
                    word = ''
                depth -= 1
            elif char == ' ':
                if word:
                    push(word, groups, depth)
                    word = ''
            else:
                word += char
    except IndexError:
        raise Exception('Parentheses mismatch')
    if depth > 0:
        raise Exception('Parentheses mismatch')
    else:
        return groups


print(parse_parentheses(s1))

#+END_SRC

#+RESULTS:
: ['Definition', 'Top.ev_4', ['App', ['Construct', ['Name', 'ev'], '2'], ['App', ['Construct', ['Name', 'nat'], '2'], ['App', ['Construct', ['Name', 'nat'], '2'], ['Construct', ['Name', 'nat'], '1']]], ['App', ['Construct', ['Name', 'ev'], '2'], ['Construct', ['Name', 'nat'], '1'], ['Construct', ['Name', 'ev'], '1']]]]


#+BEGIN_SRC python :session :results output

def print_list(lst, level=0):
    print('    ' * (level - 1) + '+---' * (level > 0) + lst[0])
    for l in lst[1:]:
        if type(l) is list:
            print_list(l, level + 1)
        else:
            print('    ' * level + '+---' + l)


print_list(parse_parentheses(s1))


#+END_SRC

#+RESULTS:
#+begin_example
Definition
+---Top.ev_4
+---App
    +---Construct
        +---Name
            +---ev
        +---2
    +---App
        +---Construct
            +---Name
                +---nat
            +---2
        +---App
            +---Construct
                +---Name
                    +---nat
                +---2
            +---Construct
                +---Name
                    +---nat
                +---1
    +---App
        +---Construct
            +---Name
                +---ev
            +---2
        +---Construct
            +---Name
                +---nat
            +---1
        +---Construct
            +---Name
                +---ev
            +---1
#+end_example

#+BEGIN_SRC python :session

import copy

class Tree: # node | List Tree
    def __init__(self, name):
        self._name = name
        self._children = []
        self._parent = None
        self._height = 0
    def getName(self):
        return self._name
    def setName(self, name):
        self._name = name
        return self
    def getParent(self):
        return self._parent
    def setParent(self, parent):
        self._parent = parent
        return self
    def getChildren(self):
        return copy.copy(self._children)
    def getChildrenByName(self, name):
        return list(filter(lambda ch : ch.getName() == name, self.getChildren()))
    def setChildren(self, children):
        self._children = copy.copy(children)
        child_trees = []
        for child in children:
            if isinstance(child,str):
                child_trees.append(Tree(child).setParent(self))
            else: #already is a tree
                child_trees.append(child.setParent(self))
        self._height = max(map(lambda x: x.getHeight(), child_trees)) + 1
        self._children = child_trees
        return self
    def addChild(self, child):
        if isinstance(child,str):
            child = Tree(child).setParent(self)
        else:
            child = child.setParent(self)
        self._height = max(map(lambda x: x.getHeight(), self.getChildren() + [child])) + 1
        self._children.append(child)
    def getHeight(self):
        return self._height
    def isLeaf(self):
        return self.getHeight() == 0

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session

def print_tree(tree, level=0):
    print('    ' * (level - 1) + '+---' * (level > 0) + tree.getName())
    for child in tree.getChildren():
        if child.isLeaf():
            print('    ' * level + '+---' + child.getName())
        else:
            print_tree(child, level + 1)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results output

t = Tree('root')
print(t); print(t.getName())
print_tree(t.setChildren(['hi',Tree('zach').setChildren(['zumbo']), 'there']))

#+END_SRC

#+RESULTS:
: <__main__.Tree object at 0x7fe03f6a3d30>
: root
: root
: +---hi
: +---zach
:     +---zumbo
: +---there

#+BEGIN_SRC python :session :results output

def listsToTree(lst):
    if lst:
        t = Tree(lst[0])
        for x in lst[1:]:
            if isinstance(x,str):
                t.addChild(x)
            elif isinstance(x,list):
                if x:
                    t.addChild(listsToTree(x))
    return t

p1, p2 = parse_parentheses(s1), parse_parentheses(s2)
t1, t2 = listsToTree(p1), listsToTree(p2)
print_tree(t1)

#+END_SRC

#+RESULTS:
#+begin_example
Definition
+---Top.ev_4
+---App
    +---Construct
        +---Name
            +---ev
        +---2
    +---App
        +---Construct
            +---Name
                +---nat
            +---2
        +---App
            +---Construct
                +---Name
                    +---nat
                +---2
            +---Construct
                +---Name
                    +---nat
                +---1
    +---App
        +---Construct
            +---Name
                +---ev
            +---2
        +---Construct
            +---Name
                +---nat
            +---1
        +---Construct
            +---Name
                +---ev
            +---1
#+end_example

#+BEGIN_SRC python :session
def dfs_test(tree):
    print(tree.getName())
    for child in tree.getChildren():
        dfs_test(child)

dfs_test(t1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session


def dfs(tree):
    yield(tree)
    for child in tree.getChildren():
        yield from dfs(child)

def bfs(tree):
    yield(tree)
    queue = tree.getChildren()
    while queue:
        next_tree = queue.pop(0)
        yield next_tree
        queue.extend(next_tree.getChildren())


#+END_SRC

#+BEGIN_SRC python :session


for x in iter(bfs(t1)):
    print(x.getName(), x.getHeight()) #height is longest path to a leaf


#+END_SRC

#+BEGIN_SRC python :session


#trying to minimize total num nodes
#def generateMotifs(tree):
#    #Find all subtrees with more than one occurrence
#    pass
#def pickMotif(list_of_motifs):
#    #decide which motifs to use for compression
#def compressTree(tree, motif):
# finish when no more motifs


#+END_SRC

#+BEGIN_SRC python :session


#def checkEqual(t1,t2):
def subset(l1,l2): #check l1 subset of l2
    return all([l in l2 for l in l1])

def subsetWithCounting(l1,l2): #check l1 bag subset of l2
    return all([l1.count(l)<=l2.count(l) for l in l1])

def checkSubTreeAtGivenStart(t1,t2): #non-intersect pick first
    if t1.getName() != t2.getName(): return False
    t1_children_names = list(map(lambda ch : ch.getName(), t1.getChildren()))
    if not subsetWithCounting(t1_children_names, list(map(lambda ch: ch.getName(),t2.getChildren()))):
        return False
    if t1.isLeaf(): return True
    return all([checkSubTreeAtGivenStart(t1.getChildrenByName(name)[0],
                                         t2.getChildrenByName(name)[0])
                for name in t1_children_names])


#+END_SRC

#+BEGIN_SRC python :session

print(subset([1,1],[1]))
print(subsetWithCounting([1,1],[1]))
print()

t1 = Tree('a').setChildren(['c','b'])
t2 = Tree('a').setChildren(['b','c'])
print_tree(t1)
print_tree(t2)
print(checkSubTreeAtGivenStart(t1,t2))
print()

t1 = Tree('a').setChildren(['c','b','c'])
t2 = Tree('a').setChildren(['b','c'])
print_tree(t1)
print_tree(t2)
print(checkSubTreeAtGivenStart(t1,t2))

#+END_SRC

#+BEGIN_SRC python :session

#using non-intersecting matches for simplicity
def getAllSubtreeMatches(t1,t2): #num times t1 in t2
    return [t2_start for t2_start in iter(bfs(t2) if)
        checkSubTreeAtGivenStart(t1,t2_start)]

def findDuplicateSubtrees(tree): #let order matter here
    seen_trees = set([])
    dfs_iterator = iter(dfs(t1))
    for start_node in dfs_iterator:
        bfs_iterator_from_start_node = iter(bfs(start_node))
        next(bfs_iterator_from_start_node) #skip start_node itself
        for end_node

#+END_SRC


#+BEGIN_SRC python :session

class Solution(object):
    def findDuplicateSubtrees(self, root):
        count = collections.Counter()
        ans = []
        def collect(node):
            if not node: return "#"
            serial = "{},{},{}".format(node.val, collect(node.left), collect(node.right))
            count[serial] += 1
            if count[serial] == 2:
                ans.append(node)
            return serial

        collect(root)
        return ans

#+END_SRC
