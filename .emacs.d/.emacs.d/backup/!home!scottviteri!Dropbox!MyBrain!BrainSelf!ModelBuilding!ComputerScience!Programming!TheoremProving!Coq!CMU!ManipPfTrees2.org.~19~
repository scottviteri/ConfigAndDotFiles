#+TITLE: Manipulate Proof Trees
#+OPTIONS: tex:t
#+STARTUP: latexpreview
#+LATEX_HEADER: \usepackage{qtree,tiks}


* Manip Proof Trees

** Tree reading / manipulation utilities

*** Read trees into python nested lists

First, grab some sample proof trees.

#+BEGIN_SRC python :session
even_4_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2))'
even_8_string = '(Definition Top.ev_2 (App ev_SS O ev_0)) (Definition Top.ev_4 (App ev_SS (App S (App S O)) Top.ev_2)) (Definition Top.ev_8 (App ev_SS (App S (App S (App S (App S (App S (App S O)))))) (App ev_SS (App S (App S (App S (App S O)))) Top.ev_4)))'
#+END_SRC

#+RESULTS:

We will need to parse these into a form that python can more directly read.

I am using a list of lists, where [A,B,[C,D]] represents
 A
 |\
 B C
   |
   D

#+BEGIN_SRC python :session :results output

import math
import copy
import itertools
import pickle
import ast
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import json
import functools
import pdb
import cProfile
import subprocess

def push(obj, l, depth):
    while depth:
        l = l[-1]
        depth -= 1
    l.append(obj)


def stringToLists(s):
    s = s[1:-1]
    groups = []
    depth = 0
    try:
        word = ''
        for char in s:
            if char == '(':
                push([], groups, depth)
                depth += 1
            elif char == ')':
                if word:
                    push(word, groups, depth)
                    word = ''
                depth -= 1
            elif char == ' ':
                if word:
                    push(word, groups, depth)
                    word = ''
            else:
                word += char
    except IndexError:
        raise Exception('Parentheses mismatch')
    if depth > 0:
        raise Exception('Parentheses mismatch')
    else:
        return groups


def focusToNewLetters(focus_string):
    if focus_string[1] == '(': return '['
    elif focus_string[1] == ')': return ']'
    elif focus_string[1] == ' ': return ','
    if focus_string[1].isalnum() \
        and (focus_string[0] == '(' or focus_string[0] == ' ') \
        and (focus_string[2] == ')' or focus_string[2] == ' '):
        return '\"'+focus_string[1]+'\"'
    if focus_string[1] not in '( )' and (focus_string[0] == '(' or focus_string[0] == ' '):
        # (a -> ("a or ' a' -> ' "a'
        return '\"'+focus_string[1]
    if focus_string[1] not in '( )' and (focus_string[2] == ')' or focus_string[2] == ' '):
        # b) -> b") or 'b ' -> 'b" '
        return focus_string[1]+'\"'
    return focus_string[1]


def isFlat(l):
    return not any(filter(lambda x: isinstance(x,list), l))

def concat(lst_of_lsts):
    return functools.reduce(lambda x,y:x+y, lst_of_lsts, [])

def printTreeHelper(tree):
    """ Prints tree by prepending '+---' to each layer
    Example: printTreeHelper(['Definition', 'Top.ev_2', ['App', 'ev_SS', 'O', 'ev_0']])
    # base: ['App', 'ev_SS', 'O', 'ev_0'] -> ['App', '+---ev_SS', '+---O', '+---ev_0']
    # ind_step: ['Definition', 'Top.ev_2', ['App', '+---ev_SS', '+---O', '+---ev_0']]
    #  -> ['Definition', '+---Top.ev_2', '+---App', '+---+---ev_SS', '+---+---O', '+---+---ev_0']]
    """
    h,t = tree[0], tree[1:]
    if not isinstance(tree, list):
        assert(isinstance(tree, str))
        return [tree]
    if isFlat(tree):
        return [h] + list(map(lambda x: "+---"+x, t))
    return [h] + concat([list(map(lambda x: "+---"+x, printTreeHelper(x))) for x in t])

def printTree(tree, max_depth=None):
    for x in printTreeHelper(tree):
        if max_depth is not None:
            if "+---"*max_depth not in x:
                print(x)
        else:
            print(x)


# let search_val be a flat list
def replaceFlatList(lst_of_lsts, search_val, replace_val):
    l = []
    for x in lst_of_lsts:
        if search_val == x:
            l.append(replace_val)
        else:
            if isinstance(x,list):
                if isFlat(x):
                    l.append(x)
                else:
                    l.append(replaceFlatList(x, search_val, replace_val))
            else:
                l.append(x)
    return l

def subNats(lst_of_lsts):
    l = replaceFlatList(lst_of_lsts, ['App','S','O'], '1')
    last_l = None
    n = 1
    while last_l != l:
       last_l = l
       l = replaceFlatList(l, ['App','S',str(n)], str(n+1))
       n += 1
    return l

def parenStringToLists(string, is_filename=False):
    accum = ''
    if is_filename:
        with open(string, 'r') as f:
            paren_string = f.read()
    else:
        paren_string = string
    paren_string = paren_string.strip()
    #print(paren_string.count('('), paren_string.count(')'))
    assert(paren_string.count('(') == paren_string.count(')'))
    rooted_paren_string = '(Top ' + paren_string + ')'
    focus = "  " + rooted_paren_string[0]
    for char in rooted_paren_string[1:]:
        focus = focus[1:] + str(char)
        accum += focusToNewLetters(focus)
        #print(focus[1], focusToNewLetters(focus))
    accum += ']'
    with open('fdsa.txt','w') as f:
        f.write(accum)
    return subNats(json.loads(accum))

print(parenStringToLists('(a b (c d e))'))
print()

l1_from_file = parenStringToLists('../100FamousProofs/Proofs/ev_4_2/d2.txt', True)
print(l1_from_file)

l1 = parenStringToLists(even_4_string)
#assert(l1 == l1_from_file)
# l1 and l1_from_file are now two separate definitions

#+END_SRC

#+RESULTS:
: ['Top', ['a', 'b', ['c', 'd', 'e']]]
:
: ['Top', ['Definition', 'ev.add_even_even', ['Lambda', 'n', 'nat', ['Lambda', 'm', 'nat', ['Lambda', 'Hm', ['App', 'ev', 'm'], ['Lambda', 'Hn', ['App', 'ev', 'n'], ['App', 'ev.ev_ind', ['Lambda', 'm', 'nat', ['App', 'ev', ['App', 'Coq.Init.Nat.add', 'm', 'n']]], ['Cast', 'Hn', 'REVERTcast', ['App', 'ev', ['App', 'Coq.Init.Nat.add', 'O', 'n']]], ['Lambda', 'n0', 'nat', ['Lambda', 'Hm', ['App', 'ev', 'n0'], ['Lambda', 'IHHm', ['App', 'ev', ['App', 'Coq.Init.Nat.add', 'n0', 'n']], ['Cast', ['App', 'ev_SS', ['App', 'Coq.Init.Nat.add', 'n0', 'n'], 'IHHm'], 'REVERTcast', ['App', 'ev', ['App', 'Coq.Init.Nat.add', ['App', 'S', ['App', 'S', 'n0']], 'n']]]]]], 'm', 'Hm']]]]]], ['Definition', 'ev.ev_2', ['App', 'ev_SS', 'O', 'ev_0']], ['Definition', "ev.ev_4'", ['App', 'ev.add_even_even', '2', '2', 'ev.ev_2', 'ev.ev_2']]]

#+BEGIN_SRC python :session

def recur(lst, out_file, count=0):
    if count == 0:
        out_file.write('None ' + str(lst[0]) + ' '+ str(count) +'\n')
        #print(None, lst[0], count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
    prev = count
    for unit in lst[1:]:
        count += 1
        if isinstance(unit,list):
            out_file.write(str(prev) + ' ' + str(unit[0]) + ' '+ str(count) +'\n')
            #print(prev, unit[0], count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
        else:
            out_file.write(str(prev) + ' ' + str(unit) + ' '+ str(count) +'\n')
            #print(prev, unit, count) # "(#{list[0]}) #{prev} -> #{count}\n"if isinstance(unit, list):
        if isinstance(unit, list):
            count = recur(unit, out_file, count)
    return count


with open('out.txt','w') as f:
    recur(['A','B',['C','D','E']], f)

with open('out.txt','r') as f:
    out = f.read()
    assert([len(l.split(' ')) == 3 for l in out.split('\n')[:-1]])
    print(out)

#+END_SRC

#+RESULTS:
: 4


Want to convert from nested list format to [(parent, name, id)] format.
It will be convenient to have ids strictly decrease as we go down a tree,
  and one way we can do this is by labeling the nodes in BFS order.

In order to do this, we'll first need to build up some helper functions to deal with nested lists.

#+BEGIN_SRC python :session

def evalTuple(tuple):
    return (eval(tuple[0]),tuple[1],eval(tuple[2]))

def loadTupleTreeFromFile(filename):
    with open(filename, "r") as f:
        tuple_strings = f.readlines()[::-1]
    tuple_tree = set([evalTuple(tuple(s[:-1].split(" "))) for s in tuple_strings])
    return tuple_tree

def genTupleTree(string, is_filename=False):
    lstOfLsts = parenStringToLists(string, is_filename)
    with open('out.txt','w') as f:
        c = recur(lstOfLsts, f)
    return loadTupleTreeFromFile('out.txt')

#assert(genTupleTree(even_4_string) == genTupleTree('../100FamousProofs/Proofs/ev_4.txt',True))

even_4_tree = parenStringToLists('../100FamousProofs/Proofs/ev_4/d2.txt', True)
even_8_tree = parenStringToLists('../100FamousProofs/Proofs/ev_8/d2.txt', True)
sqrt2_tree = parenStringToLists('../100FamousProofs/Proofs/sqrt2/d3.txt', True)

#print(even_8_tree)
#+END_SRC

#+RESULTS:

*** Substitute definitions back into the original tree branch

#+BEGIN_SRC python :session

def replaceVal(lst_of_lsts, search_val, replace_val):
    """ similar to subRec, but search target is a single value """
    l = []
    for x in lst_of_lsts:
        if instance(x,list):
            l.append(replaceVal(x, search_val, replace_val))
        else:
            if search_val == x:
                l.append(replace_val)
            else:
                l.append(x)
    return l

def replaceVals(lst_of_lsts, search_replace_dict):
    """ similar to replaceVal, but multiple search targets with different replace_vals """
    l = []
    for x in lst_of_lsts:
        if isinstance(x,list):
            l.append(replaceVals(x, search_replace_dict))
        else:
            if x in search_replace_dict:
                l.append(search_replace_dict[x])
            else:
                l.append(x)
    return l

def accumMatches(lst_of_lsts, test):
    l = []
    for x in lst_of_lsts:
        if isinstance(x, list):
            l.extend(accumMatches(x, test))
        else:
            if test(x):
                l.append(x)
    return l

def inNestedList(elem, lst_of_lsts):
    for x in lst_of_lsts:
        if isinstance(x,list):
            if inNestedList(elem, x):
                return True
        else:
            if elem == x:
                return True
    return False

# note that PrintAST can append same definition many times!

def replaceDefinitions(lst_of_lsts, max_depth=math.inf):
    """ Substitute unrolled definitions back into main top level definition """
    orig_tree, dep_trees = lst_of_lsts[-1], lst_of_lsts[1:-1]
    replace_string_candidates = set(map(lambda x:x[1], dep_trees))
    replace_strings = list(filter(lambda x: inNestedList(x, orig_tree[2]), replace_string_candidates))
    replace_string_candidates = replace_string_candidates - set(replace_strings)
    #print(replace_strings)
    def_to_subtree = {x[1]:x for x in lst_of_lsts}
    depth = 0
    l = []
    search_replace_dict = {}
    while replace_string_candidates and depth < max_depth:
        search_replace_dict = {k:def_to_subtree[k] for k in def_to_subtree if k in replace_strings}
        #print('orig', orig_tree)
        orig_tree = replaceVals(orig_tree, search_replace_dict)
        depth += 1
        replace_strings = list(filter(lambda x: inNestedList(x, orig_tree[2]), replace_string_candidates))
        #replace_strings = concat([accumMatches(subtree[2], lambda x: x[:4] == "Top.")
        #                          for subtree in search_replace_dict.values()])
        replace_string_candidates = replace_string_candidates - set(replace_strings)
    search_replace_dict = {k:def_to_subtree[k] for k in def_to_subtree if k in replace_strings}
    orig_tree = replaceVals(orig_tree, search_replace_dict)
    return orig_tree

printTree(even_4_tree,4)
printTree(replaceDefinitions(even_4_tree),4)

#assert(replaceDefinitions(even_8_tree,2) == replaceDefinitions(even_8_tree))

#+END_SRC

#+RESULTS:


** Plotting features of proof trees

*** Plot utils

 #+BEGIN_SRC python :session

 def sumLsts(lsts):
     max_len = max(map(len, lsts))
     def zeroFill(lst): return lst + [0]*(max_len - len(lst))
     return list(map(sum, zip(*map(zeroFill,lsts))))

 def countNodesAtDepths(tree):
     """ Counts num nodes at each depth
     Example: countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']])
     # base: ['c','d','e'] -> [1,2], 'b' -> [1]
     # ind_step: ['a', [1], [1,2], [1,2]] -> [1,3,4]
     """
     if not isinstance(tree, list): return [1]
     h,t = tree[0], tree[1:]
     if isFlat(tree): return [1,len(t)]
     return [1] + sumLsts(list(map(countNodesAtDepths, t)))

 def countNodes(tree):
     if not isinstance(tree, list): return 1
     if isFlat(tree): return len(tree)
     return 1 + sum([countNodes(branch) for branch in tree[1:]])

 def strip(s):
     return s.split('/')[-1]

 def modStrip(s):
     l = s.split('/')
     return l[-2] + '_' + l[-1]

 assert(countNodesAtDepths(['a', 'b', ['c','d','e'], ['c','d','e']]) == [1,3,4])


 #+END_SRC

 #+RESULTS:

 #+BEGIN_SRC python :session

 def plotNodesVTreeDepth(theorem_name, max_depth, solid=False):
   fig, ax = plt.subplots(figsize=(6,6))
   root = '../100FamousProofs/Proofs/' + theorem_name
   for d in range(1,max_depth+1):
       filename = root + '/d'+str(d)+'.txt'
       if d == 1:
           ax = plt.subplot(max_depth,1,d)
       else:
           ax = plt.subplot(max_depth,1,d, sharex = ax)
       ax.set_title(theorem_name + ' depth '+str(d))
       tree = parenStringToLists(filename, is_filename=True)
       if solid:
           ax.plot(countNodesAtDepths(tree)[1:], label='No substitution')
           ax.plot(countNodesAtDepths(replaceDefinitions(tree)), label='Defn substitution')
       else:
           ax.plot(countNodesAtDepths(tree)[1:], '_', label='No substitution')
           ax.plot(countNodesAtDepths(replaceDefinitions(tree)),'|', label='Defn substitution')
       fig.tight_layout()
       ax.legend()
       if d != max_depth:
           plt.setp(ax.get_xticklabels(), visible=False)
   plt.savefig('images/'+theorem_name+'_tree_depth.png')

 def depthToNumNodes(depth, root):
    filename = root + '/d'+str(depth)+'.txt'
    tree = parenStringToLists(filename, is_filename=True)
    substitutionTree = replaceDefinitions(tree)
    return (countNodes(tree), countNodes(substitutionTree))

 def proj1(tuple_list): return list(map(lambda x:x[0], tuple_list))

 def proj2(tuple_list): return list(map(lambda x:x[1], tuple_list))

 def plotNodesVExtractionDepth(theorem_name, max_depth):
    fig, axs = plt.subplots(2, 2, sharex = True, figsize=(4,4))
    root = '../100FamousProofs/Proofs/' + theorem_name
    depth_list = list(range(1,max_depth+1))
    log_depth_list = list(map(lambda x: math.log(x), depth_list))
    num_nodes = list(map(lambda x: depthToNumNodes(x, root), depth_list))
    print(num_nodes)
    tree_num_nodes, sub_tree_num_nodes = proj1(num_nodes), proj2(num_nodes)
    axs[0][0].plot(depth_list, tree_num_nodes)
    axs[0][1].plot(depth_list, sub_tree_num_nodes)
    axs[0][0].set_title('No Sub Tree')
    axs[0][1].set_title('Sub Tree')
    axs[1][0].plot(log_depth_list, list(map(lambda x: math.log(x), tree_num_nodes)))
    axs[1][1].plot(log_depth_list, list(map(lambda x: math.log(x), sub_tree_num_nodes)))
    fig.tight_layout()
    plt.savefig('images/'+theorem_name+'_extraction_depth.png')


 """
 l = []
 for i in range(1,4):
     pi = parenStringToLists('../100FamousProofs/Proofs/ev_4_2/d'+str(i)+'.txt', True)
     tree = replaceDefinitions(pi)
     l.append(tree)
 """

 #+END_SRC

 #+RESULTS:
 :
 : l = []
 : for i in range(1,4):
 :     pi = parenStringToLists('../100FamousProofs/Proofs/ev_4_2/d'+str(i)+'.txt', True)
 :     tree = replaceDefinitions(pi)
 :     l.append(tree)

*** Plot num nodes at particular tree depths
**** ev_4

  #+BEGIN_SRC python :session :results file
      theorem_name = 'ev_4_2'
      plotNodesVTreeDepth(theorem_name,max_depth=3,solid=False)
      'images/'+theorem_name+'_tree_depth.png'
  #+END_SRC

  #+RESULTS:
  [[file:images/ev_4_2_tree_depth.png]]

**** ev_8

  #+BEGIN_SRC python :session :results file
      theorem_name = 'ev_8_2'
      plotNodesVTreeDepth(theorem_name,max_depth=3)
      'images/'+theorem_name+'_tree_depth.png'
  #+END_SRC

  #+RESULTS:
  [[file:images/ev_8_2_tree_depth.png]]

**** sqrt2

  #+BEGIN_SRC python :session :results file
      theorem_name = 'sqrt2'
      plotNodesVTreeDepth(theorem_name,max_depth=5)
      'images/'+theorem_name+'_tree_depth.png'
  #+END_SRC

  #+RESULTS:
  [[file:images/sqrt2_2_tree_depth.png]]

**** binomial

  #+BEGIN_SRC python :session :results file
      theorem_name = 'binomial'
      plotNodesVTreeDepth(theorem_name,max_depth=4)
      'images/'+theorem_name+'_tree_depth.png'
  #+END_SRC

  #+RESULTS:
  [[file:images/binomial_2_tree_depth.png]]

**** birthday

  #+BEGIN_SRC python :session :results file
      theorem_name = 'birthday'
      plotNodesVTreeDepth(theorem_name, max_depth=6)
      'images/'+theorem_name+'_tree_depth.png'
  #+END_SRC

  #+RESULTS:
  [[file:images/birthday_2_tree_depth.png]]

*** Plot num nodes of the tree at particular extraction depths
**** ev_4

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_4'
    plotNodesVExtractionDepth(theorem_name,max_depth=3)
    'images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:images/ev_4_2_extraction_depth.png]]

**** ev_8_2

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    plotNodesVExtractionDepth(theorem_name,max_depth=3)
    'images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:images/ev_8_2_extraction_depth.png]]

**** sqrt2

#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2'
    plotNodesVExtractionDepth(theorem_name,max_depth=9)
    'images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:images/sqrt2_2_extraction_depth.png]]

**** binomial

#+BEGIN_SRC python :session :results file
    theorem_name = 'binomial'
    plotNodesVExtractionDepth(theorem_name,max_depth=6)
    'images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:images/binomial_2_extraction_depth.png]]

**** birthday

#+BEGIN_SRC python :session :results file
    theorem_name = 'birthday'
    plotNodesVExtractionDepth(theorem_name, max_depth=6)
    'images/'+theorem_name+'_extraction_depth.png'
#+END_SRC

#+RESULTS:
[[file:images/birthday_2_extraction_depth.png]]

*** Plot subtree sizes

#+BEGIN_SRC python :session

    def getTreeSize(tree):
        c = 0
        for x in tree:
            if isinstance(x,list):
                c += getTreeSize(x)
            else:
                c += 1
        return c

    def createSubtreeSizePlot(theorem_name, max_depth, num_bins=10, debug=False):
        fig, axs = plt.subplots(max_depth, 1, sharex = True, figsize=(6,6))
        root = '../100FamousProofs/Proofs/' + theorem_name
        for d in range(1,max_depth+1):
            filename = root + '/d'+str(d)+'.txt'
            tree = parenStringToLists(filename, is_filename=True)
            if debug:
                printTree(tree)
            distrib = list(map(getTreeSize, tree[1:]))
            print(distrib)
            if max_depth > 1:
                axs[d-1].hist(distrib, bins=num_bins)
                axs[d-1].set_title(theorem_name + ' subtree sizes at depth ' + str(d))
            else:
                axs.hist(distrib, bins=num_bins)
                axs.set_title(theorem_name + ' subtree sizes at depth ' + str(d))
            #print(distrib)
        plt.savefig('images/'+theorem_name+'_subtree_sizes.png')

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_4'
    #createSubtreeSizePlot(theorem_name, max_depth=3)
    'images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:images/ev_4_2_subtree_sizes.png]]

The two subtrees just happen to be the same size for ev_4 at extraction depth 2.

#+BEGIN_SRC python :session :results file
    theorem_name = 'ev_8'
    #createSubtreeSizePlot(theorem_name, max_depth=3)
    'images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:images/ev_8_2_subtree_sizes.png]]


#+BEGIN_SRC python :session :results file
    theorem_name = 'sqrt2'
    #createSubtreeSizePlot(theorem_name, max_depth=5, num_bins=50)
    'images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:images/sqrt2_2_subtree_sizes.png]]

Massive outliers are inherent.

#+BEGIN_SRC python :session :results file
    theorem_name = 'binomial'
    #createSubtreeSizePlot(theorem_name, max_depth=4, num_bins = 50)
    'images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:images/binomial_2_subtree_sizes.png]]


#+BEGIN_SRC python :session :results file
    theorem_name = 'ballot'
    #createSubtreeSizePlot(theorem_name, max_depth=4, num_bins=50)
    'images/'+theorem_name+'_subtree_sizes.png'
#+END_SRC

#+RESULTS:
[[file:images/ballot_2_subtree_sizes.png]]


** Create connectedness graph of theorems

*** Plot graphs


Goal: given a collection of theorems, create the list of theorems that they reference.
 Then use these theorems and lists to generate a directed graph.

How to deal with extraction depth?
 Use only extraction depth 1.
 This way we only generate the graph of "local" dependencies

How to start?
 Use even_4 and even_8. There should be a dependencies from even_8 to even_4.
 Then move on to standard library.

#+BEGIN_SRC python :session :results file
import networkx as nx

# remember to look at Top. in use of binomial earlier

def plotDependencyGraph(graph, outfile, label=False, figsize=(4,4)):
    plt.figure(figsize=figsize)
    nx.spring_layout(g, k=5/math.sqrt(g.order()))
    nx.draw(g, with_labels=label)
    l,r = plt.xlim()
    plt.xlim(l-.2,r+.2)
    plt.savefig(outfile)

def getDependencyGraph(theorem_list):
    theorems_to_dependencies = {}
    for theorem in theorem_list:
        orig_tree, dep_trees = theorem[-1], theorem[1:-1]
        theorems_to_dependencies[orig_tree[1]] = list(map(lambda x:x[1], dep_trees))
        #print('l:',len(theorems_to_dependencies[orig_tree[1]]))
    #print(theorems_to_dependencies)
    return nx.DiGraph(theorems_to_dependencies)

def namesToTheorems(location_list, level=2):
   return [parenStringToLists('../100FamousProofs/Proofs/'+l+'/d'+str(level)+'.txt', True) for l in location_list]

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results file
outfile = 'images/ev_4_8_dependencies.png'

theorem_list = namesToTheorems(['ev_4','ev_8'])
g = getDependencyGraph(theorem_list)
plotDependencyGraph(g, outfile, label=True)
outfile
#+END_SRC

#+RESULTS:
[[file:images/ev_4_8_dependencies.png]]

#+BEGIN_SRC python :session :results file
outfile = 'images/sqrt2_dependencies.png'
theorem_list = namesToTheorems(['sqrt2'], level=2)
g = getDependencyGraph(theorem_list)
plotDependencyGraph(g, outfile, label=True, figsize = (8,6))
outfile
#+END_SRC

#+RESULTS:
[[file:images/sqrt2_dependencies.png]]

Check out binomial -- should have high out-degree

#+BEGIN_SRC python :session :results file
outfile = 'images/binomial_dependencies.png'
theorem_list = namesToTheorems(['binomial'], level=2)
g = getDependencyGraph(theorem_list)
plotDependencyGraph(g, outfile, label=True, figsize = (8,6))
outfile
#+END_SRC

#+RESULTS:
[[file:images/binomial_dependencies.png]]


Hypothesis about what is going on here:
 Library theorems have many more direct dependencies than the average Coq proof


#+BEGIN_SRC python :session :results file
theorem_names = [
"C",
"pascal_step1",
"pascal_step2",
"pascal_step3",
"pascal",
"binomial"
]

outfile = 'images/real_binomial_dependencies_d1.png'
locations = ['../100FamousProofs/Proofs/Reals/Binomial/d1/'+th+'.txt'
                     for th in theorem_names]
theorem_list = list(map(lambda x: parenStringToLists(x,True), locations))
g = getDependencyGraph(theorem_list)
plotDependencyGraph(g, outfile, label=True, figsize = (8,6))
outfile
#+END_SRC

#+RESULTS:
[[file:images/real_binomial_dependencies_d1.png]]
[[file:['Rplus_comm', 'Rplus_assoc', 'Rplus_opp_r', 'Rplus_0_l', 'Rmult_comm', 'Rmult_assoc', 'Axiom Rinv_l', 'Axiom Rmult_1_l', 'Axiom R1_neq_R0', 'Rmult_plus_distr_l', 'total_order_T', 'Rlt_asym', 'Rlt_trans', 'Rplus_lt_compat_l', 'Rmult_lt_compat_l', 'INR', 'archimed', 'is_upper_bound', 'bound', 'is_lub', 'completeness']]]

#+BEGIN_SRC python :session :results file
theorem_names = [
"C",
"pascal_step1",
"pascal_step2",
"pascal_step3",
"pascal",
"binomial"
]

outfile = 'images/real_binomial_dependencies_d2.png'
locations = ['../100FamousProofs/Proofs/Reals/Binomial/d2/'+th+'.txt'
                     for th in theorem_names]
theorem_list = list(map(lambda x: parenStringToLists(x,True), locations))
g = getDependencyGraph(theorem_list)
plotDependencyGraph(g, outfile, label=True, figsize = (8,6))
outfile
#+END_SRC

#+RESULTS:
[[file:images/real_binomial_dependencies_d2.png]]



*** What do I want to know about these graphs?

#+BEGIN_SRC python :session
nx.info(g)
#+END_SRC

#+RESULTS:
: Name:
: Type: DiGraph
: Number of nodes: 65
: Number of edges: 122
: Average in degree:   1.8769
: Average out degree:   1.8769

#+BEGIN_SRC sh :exports both
ls "../100FamousProofs/Proofs/Reals/Cauchy_prod"
#+END_SRC

#+RESULTS:
| cauchy_finite.txt |
| sum_N_predN.txt   |
| sum_plus.txt      |
#+BEGIN_SRC python :session

def getFilesFromPath(path):
    files = str(subprocess.check_output(["ls",location]))[2:-1].split("\\n")[:-1]
    #print("files", files)
    return files

def pathToTheorems(path):
    return list(map(lambda path: parenStringToLists(path, True),
                map(lambda filename: path + '/' + filename,
                    getFilesFromPath(path))))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :session :results file

outfile = 'images/real_cauchy_dependencies.png'

path = "../100FamousProofs/Proofs/Reals/Cauchy_prod"
theorems = pathToTheorems(path)
g = getDependencyGraph(theorems)
plotDependencyGraph(g, outfile, label=True, figsize = (8,6))

outfile
#+END_SRC

#+RESULTS:
[[file:images/real_cauchy_dependencies.png]]

#+BEGIN_SRC python :session
nx.info(g)
#degree distribution
#+END_SRC

#+RESULTS:
: Name:
: Type: DiGraph
: Number of nodes: 65
: Number of edges: 122
: Average in degree:   1.8769
: Average out degree:   1.8769
