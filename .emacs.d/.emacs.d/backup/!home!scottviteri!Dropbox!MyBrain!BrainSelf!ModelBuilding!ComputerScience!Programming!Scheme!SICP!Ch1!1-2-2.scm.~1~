(define (range n) 
  (define (loop count accum)
    (if (>= count n)
        accum
        (loop (+ count 1) (cons count accum))))
  (rev (loop 0 '())))


(define (flatten lst)
  (define (flatten-helper l1 l2)
    (if (nil? l1) 
        l2
        (let ((h1 (car l1)) (t1 (cdr l1)))
          (if (list? h1) 
              (if (nil? h1) 
                  (flatten-helper t1 l2)
                  (flatten-helper (cons (cdr h1) t1) 
                                  (cons (car h1) l2)))
              (flatten-helper t1 (cons h1 l2))))))
  (rev (flatten-helper lst '())))

(define (fact n)
  (define (loop count accum)
    (if (> count n)
        accum
        (loop (1+ count) (* count accum))))
  (loop 1 1))

(define (fact' n) 
  (if (= n 0)
      1
      (* n (fact' (- n 1)))))


(define (prod l1 l2)
  (cond ((nil? l1) l2)
        ((nil? l2) l1)
        (flatten (flatten (map 
                  (lambda (x) (map 
                          (lambda (y) (list x y))
                          l2))
                  l1)))))

(define (pascal n k)
  (cond ((< n 0) 0)
        ((or (< k 0) (> k n)) 0)
        ((= k 0) 1)
        ((= n k) 1)
        (else (+ (pascal (- n 1) (- k 1))
                 (pascal (- n 1) k)))))

(map (lambda (x) (apply pascal x)) (prod (range 5) (range 5)))

