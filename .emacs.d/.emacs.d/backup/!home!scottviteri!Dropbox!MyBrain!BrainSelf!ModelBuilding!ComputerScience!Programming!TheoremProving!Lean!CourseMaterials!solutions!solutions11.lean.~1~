import .normal_forms logic.basic
open tactic expr

/-
Note: we import normal_forms.lean so that you can use those procedures e.g.
to put formulas in nnf or cnf form.
-/

/-
Part I: reverting propositions
-/

/-
In the next example, the first three lines revert all the hypotheses whose
types are propositions.
-/

example (b c d e f : Prop) (h₁ : b ∧ c) (h₂ : d → e) (g : Prop) (h₃ : b ∧ f → g) :
  true :=
begin
  revert h₃,
  revert h₂,
  revert h₁,
  -- the goal is ⊢ b ∧ c → (d → e) → (b ∧ f → g) → true
  guard_target b ∧ c → (d → e) → (b ∧ f → g) → true,
  intros,
  triv
end

/-
Write a tactic that does this.

You have to be careful to revert only the propositions. For example, if you revert
"a" in the example above, Lean will also revert h₁ and h₃, since they depend on it.
-/

example (b c d e f : Prop) (h₁ : b ∧ c) (h₂ : d → e) (g : Prop) (h₃ : b ∧ f → g) :
  true :=
begin
  revert b,
  -- the goal is ⊢ ∀ (b : Prop), b ∧ c → (b ∧ f → g) → true
  guard_target ∀ (b : Prop), b ∧ c → (b ∧ f → g) → true,
  intros,
  triv
end

/-
You can use the revert tactic, but note that "in real life" (i.e. not in the
interactive "begin ... end" mode) it takes an expression as its argument.

You can also use the tactic "is_prop", but be careful: in the example above,
it is not h₁ that has type Prop, but the *type of* h₁.
-/

#check tactic.revert
#check is_prop

example (b c d e f : Prop) (h₁ : b ∧ c) (h₂ : d → e) (g : Prop) (h₃ : b ∧ f → g) :
  true :=
by do h₁ ← get_local `h₁,
      is_prop h₁ >>= trace, -- ff
      t ← infer_type h₁,
      is_prop t >>= trace, -- tt
      tactic.triv

-- a solution:

meta def has_prop_type (e : expr) : tactic bool :=
do t ← infer_type e,
   is_prop t

meta def revert_props : tactic unit :=
do l ← (local_context >>= mfilter has_prop_type),
   mmap revert l,
   return ()

example (b c d e f : Prop) (h₁ : b ∧ c) (h₂ : d → e) (g : Prop) (h₃ : b ∧ f → g) :
  true :=
begin
  revert_props,
  guard_target (b ∧ f → g) → (d → e) → b ∧ c → true,
  intros,
  trivial
end

/-
Part II: another approach to propositional theorem proving
-/

/-
This approach stems from the fact that if a formula is in negation normal form,
and all the variables in the context are assigned to "true" or "false", then
the simplifier can evaluate it.
-/

#check classical.prop_complete

example (p q : Prop) : ((p → q) → p) → p :=
begin
  nnf,
  cases (classical.prop_complete p); cases (classical.prop_complete q); simp *
end

/-
An alternative is to use `classical.cases_on`. Here it is better to use the
`refine` tactic, which uses the goal to figure out how to instantiate the
metavariables.
-/

#check classical.cases_true_false

example (p q : Prop) : ((p → q) → p) → p :=
begin
  nnf,
  refine classical.cases_true_false _ _ _ p;
    refine classical.cases_true_false _ _ _ q; simp
end

/-
First, write a tactic, "find_atom," which runs through a formula in negation normal
form (built up from "not", "and", and "or"), and return the first leaf it finds.
Note that you only have to traverse the left side of a conjunction or disjunction.
-/

-- meta def find_atom : expr → expr := sorry

meta def find_atom : expr → expr
| `(%%e₁ ∧ %%e₂) := find_atom e₁
| `(%%e₁ ∨ %%e₂) := find_atom e₁
| `(¬ %% e₁)     := find_atom e₁
| e              := e

/-
You can test it out on the example below. Your procedure should find the variable
'p'.
-/

example (p q r : Prop) (h : (¬ p ∧ q) ∨ r) : true :=
by do h ← get_local `h,
      t ← infer_type h,
      trace (find_atom t),
      triv

/-
Now write a theorem prover that does the following: given a propositional
formula in the goal, repeatedly finds an atom p, splits on `p = true` and `p = false`,
and evaluates the result using simp. Note that it is a good idea to re-evaluate
the formula each time you split, since that can simplify the result dramatically
and shorten the search.

Note that the `done` tactic tests whether the current goal has been solved. So to
call the simpilifer and then apply tactic t only if there is still work to do,
you can write "`[ simp * ] >> (done <|> t)".

If you prefer, you can use `classical.cases_true_false.`
-/

meta def tt_prover_aux : tactic unit :=
do t ← target,
   e ← to_expr ``(classical.prop_complete %%(find_atom t)),
   (cases e >> skip); `[ simp *]; (done <|> tt_prover_aux)

meta def tt_prover_aux' : tactic unit :=
do t ← target,
   refine ``(classical.cases_true_false _ _ _ %%(find_atom t)); `[ simp ];
     (done <|> tt_prover_aux)

meta def tt_prover : tactic unit := nnf; tt_prover_aux

/- Try it out on the following examples. -/

section
  variables a b c d e : Prop

  example : a ∧ b → b ∧ ¬ c → a ∨ c :=
  by tt_prover

  example : a ∧ b → b ∧ ¬ c → a ∧ ¬ c :=
  by tt_prover

  example : ((a → b) → a) → a :=
  by do tt_prover

  example : (a → b) ∧ (b → c) → a → c :=
  by tt_prover

  example (α : Type) (x y z w : α) :
    x = y ∧ (x = y → z = w) → z = w :=
  by tt_prover

  example : ¬ (a ↔ ¬ a) :=
  by tt_prover

  example : (a → b) → (¬ a → c → d) → (¬ c ∧ b → d) → (b ∧ c → ¬ a) → c → d :=
  by tt_prover
end

/-
Part III: A procedure to factor out the common part of two lists.
-/

section
universe variable u
variable {α : Type u}

/-
Assuming type α has decidable equality, the following procedure deletes
an element a from a list if it is there, and returns none otherwise.
-/

def remove [decidable_eq α] (a : α) : list α → option (list α)
| []       := none
| (b :: l) := if a = b then some l
              else match remove l with
                   | some l' := b :: l'
                   | none    := none
                   end

#eval remove 4 [1, 2, 3, 4, 4, 5, 6]  -- some [1, 2, 3, 4, 5, 6]
#eval remove 7 [1, 2, 3, 4, 5, 6]  -- none

/-
Write a procedure "list_pair_overlap" that, given l₁ and l₂, returns a triple
(l₁', l₂', shared), where "shared" are the elements that occur in both l₁ and l₂
(repeated an appropriate number of times), and l₁' and l₂' are the corresponding
lists with these elements deleted.

(You can do this recursively, but if you prefer, you can also use the
functions `list.bag_inter` and `list.diff`.)
-/

def list_pair_overlap [decidable_eq α] :
  list α → list α → list α × list α × list α
| []      l₂ := ([], l₂, [])
| (a::l₁) l₂ := match remove a l₂ with
                | some l :=
                  let (l₁', l₂', shared) := list_pair_overlap l₁ l in
                  (l₁', l₂', a :: shared)
                | none   :=
                  let (l₁', l₂', shared) := list_pair_overlap l₁ l₂ in
                  (a::l₁', l₂', shared)
                end

/- You can try it out by evaluating this: -/

#eval list_pair_overlap [1, 2, 3, 4, 5, 5, 6, 7] [5, 2, 8, 3, 5, 5]

/-
  An appropriate output is this:

  ([1, 4, 6, 7], ([8, 5], [2, 3, 5, 5]))

The order of the elements of the list does not matter, though. -/

end

/-
Part IV:  commutative monoid cancellation
-/

/-
Given an expression like a + (b + c) + d, the following
procedure produces the list of expressions [a, b, c, d]
-/

meta def sum_to_list : expr → list expr
| `(has_add.add %%a %%b) := sum_to_list a ++ sum_to_list b
| e                      := [e]

/-
Write a procedure that goes in the other direction, that is, given a list of
expressions [a, b, c, d], returns the expression a + b + c + d.
-/

meta def list_to_sum : list expr → tactic expr
| []       := to_expr ``(0)
| [e]      := return e
| (e :: l) := do e' ← list_to_sum l,
                 to_expr ``(%%e + %%e')

/-
On the empty list, it can return the expression 0, which you can get using
to_expr ``(0).

You can test it out on the example below:
-/

example (a b c d e : ℕ) (h : a + (b + c) + (d + e) = a) : true :=
by do h ← get_local `h,
      t ← infer_type h,
      match t with
      | `(%%e₁ = %%e₂) :=
         let l := sum_to_list e₁ in
         do trace l,
            e' ← list_to_sum l,
            trace e'
      | _ := failed
      end,
      triv

/-
The two trace statements should yield the following output:

  [a, b, c, d, e]
  a + (b + (c + (d + e)))
-/

/-
Let's use this to write a tactic that cancels common parts of a sum.
For example, it should reduce the goal

  a + (b + b + c) + d = e + (c + b) + a

to

  b + d = e

To figure out how to write it, let's try this example by hand first.
-/

example (a b c d e : ℕ) (h : b + d = e) : a + (b + b + c) + d = e + (c + b) + a :=
begin
  have h₁ : a + (b + b + c) + d = (a + b + c) + (b + d),
    simp,
  apply eq.trans h₁,
  symmetry, -- turn the equation around
  have h₂ : e + (c + b) + a = (a + b + c) + e,
    simp,
  apply eq.trans h₂,
  symmetry,
  apply congr_arg, -- goal is now b + d = e!
  apply h
end

/-
Your tactic should do all but the last step, so that this works:

example (a b c d e : ℕ) (h : b + d = e) : a + (b + b + c) + d = e + (c + b) + a :=
begin
  add_cancel_tac,
  apply h
end
-/

meta def add_cancel_tac : tactic unit :=
do t ← target,
   match t with
   | `(%%e₁ = %%e₂) :=
     let l₁ := sum_to_list e₁ in
     let l₂ := sum_to_list e₂ in
     let (l₁' , l₂', l₃') := list_pair_overlap l₁ l₂ in
     do e₁' ← list_to_sum l₁',
        e₂' ← list_to_sum l₂',
        e₃' ← list_to_sum l₃',
        n₁ ← get_unused_name `h,
        e₄ ← to_expr ``(%%e₁ = %%e₃' + %%e₁'),
        h₁ ← assert n₁ e₄,
        `[ simp ],
        n₂ ← get_unused_name `h,
        e₅ ← to_expr ``(%%e₂ = %%e₃' + %%e₂'),
        h₂ ← assert n₂ e₅,
        `[ simp ],
        to_expr ``(eq.trans %%h₁) >>= apply,
        symmetry,
        to_expr ``(eq.trans %%h₂) >>= apply,
        symmetry,
        applyc ``congr_arg
   | _ := failed
   end

example (a b c d e : ℕ) (h : b + d = e) : a + (b + b + c) + d = e + (c + b) + a :=
begin
  add_cancel_tac,
  apply h
end

example (a b c d e : ℕ) (h : c = a) : a + (c + b + c) + d = d + (c + b) + a + a :=
begin
  add_cancel_tac,
  apply h
end

/-
Here is a sketch of what you should do:

Get the target, t, and use

  match t with
  | `(%%e₁ = %%e₂) := ...
  | _ := failed
  end

to get the left and right sides of the equality. Then use the procedures
above to get expressions e₁', e₂', e₃' such that e₁ is equal to e₃' + e₁' and
e₂ is equal to e₃' + e₂'.

Then carry out all the steps in the example, but with "real" tactics instead of
the interactive ones. For example, you can use

    n₁ ← get_unused_name `h,
    e₄ ← to_expr ``(%%e₁ = %%e₃' + %%e₁'),
    h₁ ← assert n₁ e₄

to build the expression e₁ = e₃' + e₁', assert it, and call the resulting expression
h₁. As with the `have` command, it leaves you the goal to prove. You can use
`[ simp ] to call the usual interactive simp tactic.

Note that

  applyc ``congr_arg

has the same net effect as

  to_expr ``(congr_arg) >>= apply

Use lots of "trace" statements to debug!
-/
