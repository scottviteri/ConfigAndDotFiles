module ListOps
  ( length
  , reverse
  , map
  , filter
  , foldr
  , foldl'
  , (++)
  , concat
  ) where

import Prelude hiding
  ( length, reverse, map, filter, foldr, (++), concat )
import Control.Monad.Except

data StrictException = EmptyString

instance Error StrictException where
  noMsg = OtherError "A String Error"
  strMsg s = OtherError s

foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' f z xs = case xs of { [] -> throwError StrictException; h:t -> foldl f z xs}

length :: [a] -> Int
length xs = case xs of { [] -> 0; (_:t) -> 1 + length t}

reverse :: [a] -> [a]
reverse xs = case xs of { [] -> []; (h:t) -> reverse t ++ [h] }

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z xs = foldl (flip f) z (reverse xs)

map :: (a -> b) -> [a] -> [b]
map f xs = case xs of { [] -> []; h:t -> f h : map f t}

filter :: (a -> Bool) -> [a] -> [a]
filter p xs = case xs of { [] -> []; h:t -> if p h then h : filter p t else filter p t}

(++) :: [a] -> [a] -> [a]
xs ++ ys = case xs of { [] -> ys; h:t -> h:(t ++ ys)}

concat :: [[a]] -> [a]
concat xss = case xss of { [] -> []; h:t -> h ++ concat t}
