open classical
local attribute [instance] prop_decidable

/- The "local attribute" lets you use the by_cases
   and by_contradiction tactics. -/

example (p : Prop) : p ∨ ¬ p :=
begin
  by_cases p,
  { left, assumption },
  right, assumption
end

example (p : Prop) : p ∨ ¬ p :=
begin
  by_cases h' : p,
  { left, exact h' },
  right, exact h'
end

/-
Give a calculational proof of the theorem log_mul below. You can use the 
rewrite tactic `rw` (and `calc` if you want), but not `simp`.

These objects are actually defined in mathlib, but for now, we'll
just declare them.
-/

constant real : Type
@[instance] constant  orreal : ordered_ring real
constants (log exp : real → real)
constant  log_exp_eq : ∀ x, log (exp x) = x
constant  exp_log_eq : ∀ {x}, x > 0 → exp (log x) = x
constant  exp_pos    : ∀ x, exp x > 0
constant  exp_add    : ∀ x y, exp (x + y) = exp x * exp y

example (x y z : real) :
  exp (x + y + z) = exp x * exp y * exp z :=
by rw [exp_add, exp_add]

example (y : real) (h : y > 0)  : exp (log y) = y :=
exp_log_eq h

theorem log_mul {x y : real} (hx : x > 0) (hy : y > 0) :
  log (x * y) = log x + log y :=
sorry

/-
These are all theorems you proved on the second and third assignments. 
Do them again, using tactics.
-/

section

variables {p q r : Prop}

example : (p → q) → (¬q → ¬p) := sorry

example : (p → (q → r)) → (p ∧ q → r) := sorry

example : p ∧ ¬q → ¬(p → q) := sorry

example : (¬p ∨ q) → (p → q) := sorry

example : (p ∨ q → r) → (p → r) ∧ (q → r) := sorry

example : (p → q) → (¬p ∨ q) := sorry

end

section

variables {α β : Type} (p q : α → Prop) (r : α → β → Prop)

example : (∀ x, p x) ∧ (∀ x, q x) → ∀ x, p x ∧ q x := sorry

example : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x := sorry

example : (∃ x, ∀ y, r x y) → ∀ y, ∃ x, r x y := sorry

theorem e1 : (¬ ∃ x, p x) → ∀ x, ¬ p x := sorry

example : (¬ ∀ x, ¬ p x) → ∃ x, p x := sorry

end

/- The rest of this assignment is only required of graduate students! -/

/- Give tactic proofs of the following. -/
section

variables (man : Type) (barber : man)
variable  (shaves : man → man → Prop)

example (h : ∀ x : man, shaves barber x ↔ ¬ shaves x x) : false := sorry

end

section

variables {α : Type} (p : α → Prop) (r : Prop) (a : α)

example : (r → ∃ x, p x) → ∃ x, (r → p x) := sorry

end

/-
Prove the theorem below, using only the ring properties of ℤ enumerated 
in Section 4.2 and the theorem sub_self. You should probably work out 
a pen-and-paper proof first.
-/

#check sub_self

example (x : ℤ) : x * 0 = 0 :=
sorry