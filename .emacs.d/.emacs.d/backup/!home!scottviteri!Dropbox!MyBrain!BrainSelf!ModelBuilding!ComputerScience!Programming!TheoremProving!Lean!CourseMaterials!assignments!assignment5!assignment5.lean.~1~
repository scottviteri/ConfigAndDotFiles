/- For these problems, you can use `rw`, but not `simp`. -/

/- Remember that addition and multiplication are defined by recursion on the
   second argument. Also, `1` is definitionally the same as `nat.succ 0`.
-/

section

variables m n : ℕ 

example : n + 0 = n := rfl

example : n + nat.succ m = nat.succ (n + m) := rfl

example : n * 0 = 0 := rfl

example : n * (nat.succ m) = n * m + n := rfl

example : 1 = nat.succ 0 := rfl

/- these theorems also have names: -/

#check nat.add_zero
#check nat.add_succ
#check nat.mul_zero
#check nat.mul_succ

end

/-
In lecture, we proved the following:
-/

#check @nat.zero_add 
#check @nat.succ_add
#check @nat.add_assoc
#check @nat.add_comm

/- 
Using these, prove the following, using (proof terms). You can use
the `rw` tactic (and `calc`) for proofs. 

(In fact, you can use the more general theorems `add_comm`, `add_assoc`,
without the `nat` prefix.)
-/

namespace hidden

-- this means that you do not have to use the `nat.` prefix
export nat (succ)

#check succ

variables (m n k : ℕ)

theorem mul_add : m * (n + k) = m * n + m * k := sorry

theorem zero_mul : 0 * n = 0 := sorry

theorem succ_mul : succ m * n = m * n + n := sorry

theorem mul_assoc : (m * n) * k = m * (n * k) := sorry

theorem mul_comm : m * n = n * m := sorry

end hidden

/- 
Now, do them again, using the induction tactic.
-/

namespace hidden'

export nat (succ)

variables (m n k : ℕ)

theorem mul_add : m * (n + k) = m * n + m * k := sorry

theorem zero_mul : 0 * n = 0 := sorry

theorem succ_mul : succ m * n = m * n + n := sorry

theorem mul_assoc : (m * n) * k = m * (n * k) := sorry

theorem mul_comm : m * n = n * m := sorry

end hidden'

/-
Remember that lists are defined inductively with a `nil` and `cons` operation.
You can write `nil` as `[]` and `cons a l` as `a :: l`. The `1ength` function
is defined recursively. The append function, `append s t`, written `s ++ t`,
is also defined recursively.
-/

section
open list

variable {α : Type*}
variables s t : list α
variable a : α 

-- we have to give the type of `nil` here, because Lean can't infer it. 
-- we could also write `(nil : list α)`.

theorem length_nil : length (@nil α) = 0 := rfl

#check nil_append
#check cons_append
#check length_cons

#eval [1, 2, 3] ++ [4, 5]
#eval length [1, 2, 3, 4, 5]

end

/-
Prove the following.
-/

section
open list

variable {α : Type*}
variables s t : list α 
variable a : α

example : length (s ++ t) = length s + length t :=
sorry

end

/-
Define an inductive data type consisting of terms built up from the 
following constructors:

  `const n`, a constant denoting the natural number n
  `var n`, a variable, numbered n
  `plus s t`, denoting the sum of s and t
  `times s t`, denoting the product of s and t
-/

inductive nat_term
| const : ℕ → nat_term
-- ....

open nat_term

/-
Recursively define a function that evaluates any such term with respect to 
an assignment `val : ℕ → ℕ` of values to the variables.

For example, if `val 4 = 3
-/

def eval (val : ℕ → ℕ) : nat_term → ℕ :=
sorry

/-
Test it out by using #eval on some terms. You can use the following `val` function. In that case, for example, we would expect to have

  eval val (plus (const 2) (var 1)) = 5
-/

def val : ℕ → ℕ 
| 0 := 4
| 1 := 3
| 2 := 8
| _ := 0

/- uncomment these to test them out:

example : eval val (plus (const 2) (var 1)) = 5 := rfl

#eval eval val (plus (const 2) (var 1))

-/

/- 
Only graduate students are required to do the next one. This assignment is long
and this is tricky, so don't worry if you don't finish it.

Below, we define a function `rev` that reverses a list. It uses an auxiliary function
`append1`. 

If you can, prove that the length of the list is preserved, and that
`rev (rev l) = l` for every `l`. The theorem below is given as an example, and should
be helpful. 

Note that when you use the equation compiler to define a function foo, `rw [foo]` uses
one of the defining equations if it can. For example, `rw [append1, ...]` in the theorem
uses the second equation in the definition of `append1`
-/

section

open list
variable {α : Type*}

def append1 (a : α) : list α → list α 
| nil      := [a]
| (b :: l) := b :: (append1 l)

def rev : list α → list α
| nil := nil
| (a :: l) := append1 a (rev l)

theorem length_append1 (a : α) (l : list α): length (append1 a l) = length l + 1 :=
begin
  induction l with b l ih,
  { reflexivity },
  rw [append1, length_cons, length_cons, ih]
end

theorem length_rev (l : list α) : length (rev l) = length l := sorry

theorem rev_rev (l : list α) : rev (rev l) = l := sorry

end


