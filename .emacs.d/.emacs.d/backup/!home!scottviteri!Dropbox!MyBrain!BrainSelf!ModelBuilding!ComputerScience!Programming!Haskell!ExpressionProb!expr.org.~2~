
#+BEGIN_SRC haskell
:set +m
#+END_SRC

Define a basic expression language and functions that act on that language.

#+BEGIN_SRC haskell
:{
data Expr = Constant Double
            | BinaryPlus Expr Expr

stringify :: Expr -> String
stringify (Constant c) = show c
stringify (BinaryPlus e1 e2) = stringify e1 ++ " + " ++ stringify e2

evaluate :: Expr -> Double
evaluate (Constant c) = c
evaluate (BinaryPlus e1 e2) = evaluate e1 + evaluate e2
:}
#+END_SRC

#+BEGIN_SRC haskell
example = BinaryPlus (Constant 3) (Constant 4)
stringify example
evaluate example
#+END_SRC

#+RESULTS:
: 7.0

Now we want to add BinaryMul to our language.
Want to write the following lines (in pseudo-code):

data Expr = Expr | BinaryMul Expr Expr
stringify (BinaryMul e1 e2) = stringify e1 ++ " * " ++ stringify e2
evaluate (BinaryMul e1 e2) = evaluate e1 * evaluate e2

But we cannot extent the definition of Expr once it has been defined.
So let's try again, but with Expr as a typeclass.

#+BEGIN_SRC haskell
data Constant = Constant Double deriving Show
data BinaryPlus e1 e2 = BinaryPlus e1 e2 deriving Show
:k BinaryPlus
#+END_SRC

#+RESULTS:
: Prelude> BinaryPlus :: * -> * -> *

#+BEGIN_SRC haskell
class Expr e
instance Expr Constant
instance (Expr e1, Expr e2) => Expr (BinaryPlus e1 e2)
#+END_SRC

#+BEGIN_SRC haskell
class (Expr e) => Eval e where
  evaluate :: e -> Double
instance Eval Constant where
  evaluate (Constant x) = x
instance (Eval e1, Eval e2) => Eval (BinaryPlus e1 e2) where
  evaluate (BinaryPlus e1x e2x) = evaluate e1x +


#+END_SRC
